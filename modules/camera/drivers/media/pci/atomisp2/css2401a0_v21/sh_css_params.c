/*
 * Support for Intel Camera Imaging ISP subsystem.
 *
 * Copyright (c) 2010 - 2014 Intel Corporation. All Rights Reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License version
 * 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 *
 */

#include "gdc_device.h"		/* gdc_lut_store(), ... */
#include "isp.h"			/* ISP_VEC_ELEMBITS */
#include "vamem.h"
#if !defined(HAS_NO_HMEM)
#ifndef __INLINE_HMEM__
#define __INLINE_HMEM__
#endif
#include "hmem.h"
#endif /* !defined(HAS_NO_HMEM) */

#define IA_CSS_INCLUDE_PARAMETERS
#define IA_CSS_INCLUDE_ACC_PARAMETERS

#include "sh_css_params.h"
#include "ia_css_queue.h"
#include "sw_event_global.h"		/* Event IDs */

#include "assert_support.h"
#include "math_support.h"	/* max(), min() */

#include "ia_css_stream.h"
#include "sh_css_params_internal.h"
#include "sh_css_param_shading.h"
#include "sh_css_param_dvs.h"
#include "ia_css_refcount.h"
#include "sh_css_internal.h"
#include "sh_css_defs.h"
#include "sh_css_sp.h"
#include "ia_css_pipeline.h"
#include "ia_css_debug.h"
#include "memory_access.h"
#include "ia_css_isp_param.h"

/* Include all kernel host interfaces for ISP1 */
#include "anr/anr_1.0/ia_css_anr.host.h"
#include "cnr/cnr_1.0/ia_css_cnr.host.h"
#include "csc/csc_1.0/ia_css_csc.host.h"
#include "de/de_1.0/ia_css_de.host.h"
#include "dp/dp_1.0/ia_css_dp.host.h"
#include "bnr/bnr_1.0/ia_css_bnr.host.h"
#include "fpn/fpn_1.0/ia_css_fpn.host.h"
#include "gc/gc_1.0/ia_css_gc.host.h"
#include "macc/macc_1.0/ia_css_macc.host.h"
#include "ctc/ctc_1.0/ia_css_ctc.host.h"
#include "ob/ob_1.0/ia_css_ob.host.h"
#include "raw/raw_1.0/ia_css_raw.host.h"
#include "s3a/s3a_1.0/ia_css_s3a.host.h"
#include "sc/sc_1.0/ia_css_sc.host.h"
#include "tnr/tnr_1.0/ia_css_tnr.host.h"
#include "uds/uds_1.0/ia_css_uds.host.h"
#include "wb/wb_1.0/ia_css_wb.host.h"
#include "ynr/ynr_1.0/ia_css_ynr.host.h"
#include "xnr/xnr_1.0/ia_css_xnr.host.h"

/* Include additional kernel host interfaces for ISP2 */
#include "aa/aa_2/ia_css_aa2.host.h"
#include "anr/anr_2/ia_css_anr2.host.h"
#include "bh/bh_2/ia_css_bh.host.h"
#include "cnr/cnr_2/ia_css_cnr2.host.h"
#include "de/de_2/ia_css_de2.host.h"
#include "gc/gc_2/ia_css_gc2.host.h"
#include "ctc/ctc_2/ia_css_ctc2.host.h"
#include "ynr/ynr_2/ia_css_ynr2.host.h"

#include "platform_support.h"
#include "ia_css_eventq.h"

#if defined(IS_ISP_2500_SYSTEM)
#include "product_specific.host.h"
#include "components/stats_3a/src/stats_3a_private.h"
#include "components_types.host.h"                /* Skylake kernel settings structs */
#endif

#include "sh_css_frac.h"

/* Convenience macro to force a value to a lower even value.
 *  We do not want to (re)use the kernel macro round_down here
 *  because the same code base is used internally by Silicon Hive
 *  simulation environment, where the kernel macro is not available
 */
#define EVEN_FLOOR(x)	(x & ~1)

#define FPNTBL_BYTES(binary) \
	(sizeof(char) * (binary)->in_frame_info.res.height * \
	 (binary)->in_frame_info.padded_width)
#define SCTBL_BYTES(binary) \
	(sizeof(unsigned short) * (binary)->sctbl_height * \
	 (binary)->sctbl_aligned_width_per_color * IA_CSS_SC_NUM_COLORS)
#if 0
#define S3ATBL_BYTES(binary) \
	(sizeof(struct ia_css_3a_output) * (binary)->s3atbl_isp_width * \
	 (binary)->s3atbl_isp_height)
#endif
/* TODO: check if the stride is always the same max value or whether
 * it varies per resolution. */
#if 0
#define S3ATBL_HI_LO_BYTES(binary) \
	(ISP_S3ATBL_HI_LO_STRIDE_BYTES * (binary)->s3atbl_isp_height)
#endif
/* SDIS */
#define SDIS_VER_COEF_TBL__IN_DMEM(b) \
	_SDIS_VER_COEF_TBL_USE_DMEM((b)->info->sp.mode, (b)->info->sp.enable.dis, (b)->info->sp.isp_pipe_version)

#define SH_CSS_DIS_VER_NUM_COEF_TYPES(b) \
  (((b)->info->sp.isp_pipe_version == 2) ? IA_CSS_DVS2_NUM_COEF_TYPES : \
	(SDIS_VER_COEF_TBL__IN_DMEM(b) ? \
		IA_CSS_DVS_COEF_TYPES_ON_DMEM : \
		IA_CSS_DVS_NUM_COEF_TYPES))

#define SDIS_HOR_COEF_TBL_BYTES(b) \
	(sizeof(short) * (((b)->info->sp.isp_pipe_version == 2) ? IA_CSS_DVS2_NUM_COEF_TYPES : IA_CSS_DVS_NUM_COEF_TYPES) * (b)->dis_hor_coef_num_isp)
#define SDIS_VER_COEF_TBL_BYTES(b) \
	(sizeof(short) * SH_CSS_DIS_VER_NUM_COEF_TYPES(b) * \
		(b)->dis_ver_coef_num_isp)
#if 0
#define SDIS_HOR_PROJ_TBL_BYTES(b) \
	(sizeof(int)   * IA_CSS_DVS_NUM_COEF_TYPES * (b)->dis_hor_proj_num_isp)
#define SDIS_VER_PROJ_TBL_BYTES(b) \
	(sizeof(int)   * IA_CSS_DVS_NUM_COEF_TYPES * (b)->dis_ver_proj_num_isp)
#endif
#define MORPH_PLANE_BYTES(binary) \
	(SH_CSS_MORPH_TABLE_ELEM_BYTES * (binary)->morph_tbl_aligned_width * \
	 (binary)->morph_tbl_height)

#define PIX_SHIFT_FILTER_RUN_IN_X 12
#define PIX_SHIFT_FILTER_RUN_IN_Y 12

#if defined(IS_ISP_2500_SYSTEM)
static struct sh_css_acc_cluster_parameters acc_cluster_parameters;
#endif

/* We keep a second copy of the ptr struct for the SP to access.
   Again, this would not be necessary on the chip. */
static hrt_vaddress sp_ddr_ptrs;

/* sp group address on DDR */
static hrt_vaddress xmem_sp_group_ptrs;

static hrt_vaddress xmem_sp_stage_ptrs[IA_CSS_PIPE_ID_NUM]
						[SH_CSS_MAX_STAGES];
static hrt_vaddress xmem_isp_stage_ptrs[IA_CSS_PIPE_ID_NUM]
						[SH_CSS_MAX_STAGES];

/* END DO NOT MOVE INTO VIMALS_WORLD */

/* Digital Zoom lookup table. See documentation for more details about the
 * contents of this table.
 */
#if !defined(IS_ISP_2500_SYSTEM)
#if defined(HAS_GDC_VERSION_2)
static const int zoom_table[4][HRT_GDC_N] = {
		 {0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
		 -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,
		 -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,
		 -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,
		 -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,
		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
		 -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,
		 -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,
		 -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,
		 -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,
		 -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,
		 -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,
		 -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
		 -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
		 -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
		 -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
		 -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,
		 -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,
		 -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,
		 -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,
		 -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,
		 -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,
		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
		-10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4,
		-10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4,
		-11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4,
		-11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4,
		-11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4,
		-11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4,
		-12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
		-12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
		-13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4,
		-13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4,
		-13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4,
		-13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4,
		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
		-13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4,
		-13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4,
		-12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
		-12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
		-11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4,
		-11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4,
		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
		 -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,
		 -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,
		 -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,
		 -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,
		 -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,
		 -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,
		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4},
		 {0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
		  2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4,
		  2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4,
		  4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,
		  4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,
		  7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,
		  7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,
		  9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,
		  9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,
		  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,
		  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,
		  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,
		  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,
		  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,
		  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,
		  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,
		  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,
		  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,
		  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,
		  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,
		  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,
		  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,
		  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,
		  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,
		  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,
		  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,
		  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,
		  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,
		  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,
		  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,
		  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,
		  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,
		  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,
		  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,
		  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,
		  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,
		  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,
		  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,
		  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,
		  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,
		  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,
		  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,
		  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,
		  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,
		  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,
		  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,
		  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,
		  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,
		  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,
		 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4,
		 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4,
		 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4,
		 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4,
		 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4,
		 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4,
		 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4,
		 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4,
		 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4,
		 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4,
		 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4,
		 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4,
		 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4,
		 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4,
		 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4,
		 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4,
		 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4,
		 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4,
		 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4,
		 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4,
		 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4,
		 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4,
		 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4,
		 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4,
		 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4,
		 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4,
		 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4,
		 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4,
		 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4,
		 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4,
		 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4,
		 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4,
		 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4,
		 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4,
		 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4,
		 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4,
		 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4,
		 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4,
		 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4,
		 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4,
		 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4,
		 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4,
		 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4,
		 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4,
		 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4,
		 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4,
		 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4,
		 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4,
		 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4,
		 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4,
		 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4,
		 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4,
		 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4,
		 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4,
		 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4,
		 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4,
		 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4,
		 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4,
		 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4,
		 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4,
		 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4,
		 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4,
		 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4,
		 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4,
		 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4,
		 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4,
		 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4,
		 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4,
		 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4,
		 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4,
		 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4,
		 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4,
		 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4,
		 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4,
		 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4,
		 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4,
		 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4,
	 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4},
	{256<<4, 256<<4, 256<<4, 256<<4, 256<<4, 256<<4, 256<<4, 256<<4,
		 256<<4, 256<<4, 256<<4, 256<<4, 256<<4, 256<<4, 256<<4, 256<<4,
		 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4,
		 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4,
		 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4,
		 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4,
		 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4,
		 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4,
		 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4,
		 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4,
		 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4,
		 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4,
		 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4,
		 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4,
		 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4,
		 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4,
		 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4,
		 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4,
		 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4,
		 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4,
		 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4,
		 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4,
		 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4,
		 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4,
		 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4,
		 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4,
		 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4,
		 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4,
		 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4,
		 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4,
		 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4,
		 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4,
		 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4,
		 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4,
		 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4,
		 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4,
		 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4,
		 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4,
		 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4,
		 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4,
		 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4,
		 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4,
		 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4,
		 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4,
		 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4,
		 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4,
		 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4,
		 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4,
		 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4,
		 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4,
		 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4,
		 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4,
		 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4,
		 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4,
		 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4,
		 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4,
		 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4,
		 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4,
		 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4,
		 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4,
		 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4,
		 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4,
		 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4,
		 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4,
		 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4,
		 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4,
		 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4,
		 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4,
		 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4,
		 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4,
		 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4,
		 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4,
		 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4,
		 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4,
		 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4,
		 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4,
		 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4,
		 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4,
		 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4,
		 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4,
		  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,
		  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,
		  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,
		  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,
		  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,
		  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,
		  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,
		  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,
		  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,
		  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,
		  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,
		  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,
		  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,
		  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,
		  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,
		  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,
		  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,
		  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,
		  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,
		  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,
		  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,
		  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,
		  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,
		  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,
		  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,
		  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,
		  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,
		  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,
		  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,
		  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,
		  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,
		  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,
		  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,
		  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,
		  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,
		  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,
		  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,
		  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,
		  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,
		  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,
		  9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,
		  9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,
		  7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,
		  7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,
		  4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,
		  4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,
		  2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4,
		  2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4},
		 {0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
		 -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,
		 -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,
		 -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
		 -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
		 -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,
		 -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,
		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
		-10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4,
		-10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4,
	    -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
		-12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
		-13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4,
		-13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4,
		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
		-19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4,
		-19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4,
		-19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4,
		-19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4,
		-19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4,
		-19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
	    -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
		-13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4,
		-13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4,
		-12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
		-12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
		-12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
		-12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
		-12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
		-12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
		-11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4,
		-11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4,
		-11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4,
		-11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4,
		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
		 -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,
		 -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,
		 -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
		 -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
		 -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
		 -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
	     -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
		 -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
		 -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,
		 -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,
		 -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,
		 -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,
		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
		 -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,
		 -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,
		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
		 -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,
		 -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,
		 -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,
		 -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,
		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
		  1<<4,   1<<4,   1<<4,   1<<4,   1<<4,   1<<4,   1<<4,   1<<4,
		  1<<4,   1<<4,   1<<4,   1<<4,   1<<4,   1<<4,   1<<4,   1<<4,
		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4}
};
#else
#error "sh_css_params.c: GDC version must be \
	one of {GDC_VERSION_2}"
#endif
#endif

static const struct ia_css_dz_config default_dz_config = {
	HRT_GDC_N,
	HRT_GDC_N
};

static const struct ia_css_vector default_motion_config = {
	0,
	0
};

static enum ia_css_err
ref_sh_css_ddr_address_map(
		struct sh_css_ddr_address_map *map,
		struct sh_css_ddr_address_map *out);

static enum ia_css_err
write_sh_css_address_map_to_ddr(
		struct sh_css_ddr_address_map *map,
		hrt_vaddress *out);

static enum ia_css_err
free_sh_css_ddr_address_map(hrt_vaddress ptr);

static enum ia_css_err
sh_css_params_write_to_ddr_internal(
		unsigned pipe_id,
		struct ia_css_isp_parameters *params,
		const struct ia_css_pipeline_stage *stage,
		struct sh_css_ddr_address_map *ddr_map,
		struct sh_css_ddr_address_map_size *ddr_map_size);

#if !defined(IS_ISP_2500_SYSTEM)
static void
ia_css_set_dvs_coefficients(struct ia_css_isp_parameters *params,
				const struct ia_css_dvs_coefficients *coefs)
{
	if (coefs == NULL)
		return;
	assert(params != NULL);

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
			    "ia_css_set_dvs_coefficients() enter: \
			    hcoef=%p, vcoef=%p",
			    coefs->hor_coefs, coefs->ver_coefs);
	params->dis_hor_coef_tbl = coefs->hor_coefs;
	params->dis_ver_coef_tbl = coefs->ver_coefs;
	params->dis_coef_table_changed = true;
	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
			    "ia_css_set_dvs_coefficients() leave: void\n");
}
#endif

void
ia_css_get_dvs_statistics(struct ia_css_dvs_statistics           *host_stats,
			  const struct ia_css_isp_dvs_statistics *isp_stats)
{
	unsigned int hor_num_isp, ver_num_isp, hor_num_dvs, ver_num_dvs, i;
	int *hor_ptr_dvs,
	    *ver_ptr_dvs;
	hrt_vaddress hor_ptr_isp,
		     ver_ptr_isp;

	assert(host_stats != NULL);
	assert(host_stats->hor_proj != NULL);
	assert(host_stats->ver_proj != NULL);
	assert(isp_stats != NULL);
	assert(isp_stats->hor_proj != 0);
	assert(isp_stats->ver_proj != 0);

	hor_num_isp = host_stats->grid.aligned_height;
	ver_num_isp = host_stats->grid.aligned_width;
	hor_ptr_isp = isp_stats->hor_proj;
	ver_ptr_isp = isp_stats->ver_proj;
	hor_ptr_dvs = host_stats->hor_proj;
	ver_ptr_dvs = host_stats->ver_proj;

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_get_dvs_statistics() enter: \
		hproj=%p, vproj=%p, \
		haddr=%x, vaddr=%x\n",
		host_stats->hor_proj, host_stats->ver_proj,
		isp_stats->hor_proj, isp_stats->ver_proj);

	hor_num_dvs = host_stats->grid.height;
	ver_num_dvs = host_stats->grid.width;
	for (i = 0; i < IA_CSS_DVS_NUM_COEF_TYPES; i++) {
		mmgr_load(hor_ptr_isp, hor_ptr_dvs, hor_num_dvs * sizeof(int));
		hor_ptr_isp += hor_num_isp * sizeof(int);
		hor_ptr_dvs += hor_num_dvs;

		mmgr_load(ver_ptr_isp, ver_ptr_dvs, ver_num_dvs * sizeof(int));
		ver_ptr_isp += ver_num_isp * sizeof(int);
		ver_ptr_dvs += ver_num_dvs;
	}

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
			"ia_css_get_dvs_statistics() leave: void\n");
}

#if !defined(IS_ISP_2500_SYSTEM)
static void
ia_css_set_dvs2_coefficients(struct ia_css_isp_parameters *params,
				const struct ia_css_dvs2_coefficients *coefs)
{
	if (coefs == NULL)
		return;
	assert(params != NULL);

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
			    "sh_css_set_dvs2_coefficients() enter: \
			    hor_coefs.odd_real=%p, hor_coefs.odd_imag=%p\
			    hor_coefs.even_real=%p, hor_coefs.even_imag=%p\
			    ver_coefs.odd_real=%p, ver_coefs.odd_imag=%p\
			    ver_coefs.even_real=%p, ver_coefs.even_imag=%p",
			    coefs->hor_coefs.odd_real,
			    coefs->hor_coefs.odd_imag,
			    coefs->hor_coefs.even_real,
			    coefs->hor_coefs.even_imag,
			    coefs->ver_coefs.odd_real,
			    coefs->ver_coefs.odd_imag,
			    coefs->ver_coefs.even_real,
			    coefs->ver_coefs.even_imag);

	params->dvs2_hor_coefs = coefs->hor_coefs;
	params->dvs2_ver_coefs = coefs->ver_coefs;

	params->dvs2_coef_table_changed = true;
	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_set_dvs2_coefficients() leave: void\n");
}
#endif

void
ia_css_get_dvs2_statistics(struct ia_css_dvs2_statistics           *host_stats,
			  const struct ia_css_isp_dvs_statistics *isp_stats)
{
	unsigned int hor_num_isp, ver_num_isp, hor_bytes, ver_bytes;
	hrt_vaddress hor_ptr_isp, ver_ptr_isp;

	assert(host_stats != NULL);
	assert(host_stats->hor_prod.odd_real  != NULL);
	assert(host_stats->hor_prod.odd_imag  != NULL);
	assert(host_stats->hor_prod.even_real != NULL);
	assert(host_stats->hor_prod.even_imag != NULL);
	assert(host_stats->ver_prod.odd_real  != NULL);
	assert(host_stats->ver_prod.odd_imag  != NULL);
	assert(host_stats->ver_prod.even_real != NULL);
	assert(host_stats->ver_prod.even_imag != NULL);
	assert(isp_stats != NULL);
	assert(isp_stats->hor_proj != 0);
	assert(isp_stats->ver_proj != 0);

	hor_num_isp =
	ver_num_isp = host_stats->grid.aligned_width
		    * host_stats->grid.aligned_height;

	hor_ptr_isp = isp_stats->hor_proj;
	ver_ptr_isp = isp_stats->ver_proj;

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_get_dvs2_statistics() enter: \
		hor_coefs.odd_real=%p, hor_coefs.odd_imag=%p\
		hor_coefs.even_real=%p, hor_coefs.even_imag=%p\
		ver_coefs.odd_real=%p, ver_coefs.odd_imag=%p\
		ver_coefs.even_real=%p, ver_coefs.even_imag=%p\
		haddr=%x, vaddr=%x\n",
		host_stats->hor_prod.odd_real, host_stats->hor_prod.odd_imag,
		host_stats->hor_prod.even_real, host_stats->hor_prod.even_imag,
		host_stats->ver_prod.odd_real, host_stats->ver_prod.odd_imag,
		host_stats->ver_prod.even_real, host_stats->ver_prod.even_imag,
		isp_stats->hor_proj, isp_stats->ver_proj);

	hor_bytes = hor_num_isp * sizeof(int);
	ver_bytes = ver_num_isp * sizeof(int);

	mmgr_load(hor_ptr_isp, host_stats->hor_prod.odd_real, hor_bytes);
	hor_ptr_isp += hor_bytes;
	mmgr_load(hor_ptr_isp, host_stats->hor_prod.odd_imag, hor_bytes);
	hor_ptr_isp += hor_bytes;
	mmgr_load(hor_ptr_isp, host_stats->hor_prod.even_real, hor_bytes);
	hor_ptr_isp += hor_bytes;
	mmgr_load(hor_ptr_isp, host_stats->hor_prod.even_imag, hor_bytes);

	mmgr_load(ver_ptr_isp, host_stats->ver_prod.odd_real, ver_bytes);
	ver_ptr_isp += ver_bytes;
	mmgr_load(ver_ptr_isp, host_stats->ver_prod.odd_imag, ver_bytes);
	ver_ptr_isp += ver_bytes;
	mmgr_load(ver_ptr_isp, host_stats->ver_prod.even_real, ver_bytes);
	ver_ptr_isp += ver_bytes;
	mmgr_load(ver_ptr_isp, host_stats->ver_prod.even_imag, ver_bytes);

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
			"sh_css_get_dvs2_statistics() leave: void\n");
}

#if !defined(HAS_NO_HMEM) &&  !defined(SYSTEM_css_skycam_a0t_system)
static void get_3a_stats_from_hmem(struct ia_css_3a_statistics *host_stats,
		hrt_vaddress ddr_ptr) {
#if defined(IS_ISP_2500_SYSTEM)
	(void)host_stats;
	(void)ddr_ptr;
#else
	struct ia_css_3a_rgby_output	*out_ptr;
	int			i;

	/* pixel counts(BQ) for 3A area */
	int count_for_3a;
	int sum_r, diff;

	assert(host_stats  != NULL);
	assert(host_stats->rgby_data != NULL);
	assert(ddr_ptr != mmgr_NULL);

	count_for_3a = host_stats->grid.width * host_stats->grid.height
	    * host_stats->grid.bqs_per_grid_cell
	    * host_stats->grid.bqs_per_grid_cell;

	out_ptr = host_stats->rgby_data;
	
	ia_css_bh_hmem_decode(out_ptr, ddr_ptr);

/* Calculate sum of histogram of R,
   which should not be less than count_for_3a */
	sum_r = 0;
	for (i = 0; i < HMEM_UNIT_SIZE; i++) {
		sum_r += out_ptr[i].r;
	}
	if (sum_r < count_for_3a) {
		/* histogram is invalid */
		return;
	}

/* Verify for sum of histogram of R/G/B/Y */
#if 0
{
	int sum_g = 0;
	int sum_b = 0;
	int sum_y = 0;
	for (i = 0; i < HMEM_UNIT_SIZE; i++) {
		sum_g += out_ptr[i].g;
		sum_b += out_ptr[i].b;
		sum_y += out_ptr[i].y;
	}
	if (sum_g != sum_r || sum_b != sum_r || sum_y != sum_r) {
		/* histogram is invalid */
		return;
	}
}
#endif

/*
 * Limit the histogram area only to 3A area.
 * In DSP, the histogram of 0 is incremented for pixels
 * which are outside of 3A area. That amount should be subtracted here.
 *   hist[0] = hist[0] - ((sum of all hist[]) - (pixel count for 3A area))
 */

	diff = sum_r - count_for_3a;
	out_ptr[0].r -= diff;
	out_ptr[0].g -= diff;
	out_ptr[0].b -= diff;
	out_ptr[0].y -= diff;

return;
#endif
}
#endif

#if !defined(SYSTEM_css_skycam_a0t_system)
static void get_3a_stats_from_dmem(struct ia_css_3a_statistics *host_stats,
		hrt_vaddress ddr_ptr) {


	int ddr_width, out_width, out_height, i;
	struct ia_css_3a_output *out_ptr;

	assert(host_stats != NULL);
	assert(host_stats->data != NULL);
	assert(ddr_ptr != mmgr_NULL);

	ddr_width  = host_stats->grid.aligned_width;
	out_width  = host_stats->grid.width;
	out_height = host_stats->grid.height;
	out_ptr    = host_stats->data;

	for (i = 0; i < out_height; i++) {
		mmgr_load(ddr_ptr, out_ptr, out_width * sizeof(*out_ptr));
		ddr_ptr += ddr_width * sizeof(*out_ptr);
		out_ptr += out_width;
	}
}
#endif

/* MW: this is an ISP function */
STORAGE_CLASS_INLINE int
merge_hi14bit_lo14bit(unsigned short hi, unsigned short lo)
{
	int val = (int) ((((unsigned int) hi << 14) & 0xfffc000) |
			((unsigned int) lo & 0x3fff));
	return val;
}

#if !defined(SYSTEM_css_skycam_a0t_system)
static void get_3a_stats_from_vmem(struct ia_css_3a_statistics *host_stats,
		hrt_vaddress ddr_ptr_hi, hrt_vaddress ddr_ptr_lo) {


	int out_width, out_height, chunk, rest, kmax, y, x, k, elm_start, elm, ofs,
			bytes;
	unsigned short *hi, *lo;
	struct ia_css_3a_output *output;
	/* struct size > 128 bytes should not be stored on stack (see checkpatch) */
	static unsigned short s3a_tbl_hi_buf[ISP_S3ATBL_HI_LO_STRIDE *
				     SH_CSS_MAX_BQ_GRID_HEIGHT],
		      s3a_tbl_lo_buf[ISP_S3ATBL_HI_LO_STRIDE *
				     SH_CSS_MAX_BQ_GRID_HEIGHT];

	assert(host_stats!= NULL);
	assert(host_stats->data != NULL);
	assert(ddr_ptr_hi != mmgr_NULL);
	assert(ddr_ptr_lo != mmgr_NULL);

	output = host_stats->data;
	out_width  = host_stats->grid.width;
	out_height = host_stats->grid.height;
	hi = s3a_tbl_hi_buf;
	lo = s3a_tbl_lo_buf;

	chunk = (ISP_VEC_NELEMS >> host_stats->grid.deci_factor_log2);
	chunk = max(chunk, 1);
	bytes = ISP_S3ATBL_HI_LO_STRIDE_BYTES * out_height;

	mmgr_load(ddr_ptr_hi, hi, bytes);
	mmgr_load(ddr_ptr_lo, lo, bytes);

	for (y = 0; y < out_height; y++) {
		elm_start = y * ISP_S3ATBL_HI_LO_STRIDE;
		rest = out_width;
		x = 0;
		while (x < out_width) {
			kmax = (rest > chunk) ? chunk : rest;
			ofs = y * out_width + x;
			elm = elm_start + x * sizeof(*output) / sizeof(int);
			for (k = 0; k < kmax; k++, elm++) {
				output[ofs + k].ae_y =
				    merge_hi14bit_lo14bit
				    (hi[elm], lo[elm]);
				output[ofs + k].awb_cnt =
				    merge_hi14bit_lo14bit
				    (hi[elm + chunk], lo[elm + chunk]);
				output[ofs + k].awb_gr =
				    merge_hi14bit_lo14bit
				    (hi[elm + chunk * 2],
				     lo[elm + chunk * 2]);
				output[ofs + k].awb_r =
				    merge_hi14bit_lo14bit
				    (hi[elm + chunk * 3],
				     lo[elm + chunk * 3]);
				output[ofs + k].awb_b =
				    merge_hi14bit_lo14bit
				    (hi[elm + chunk * 4],
				     lo[elm + chunk * 4]);
				output[ofs + k].awb_gb =
				    merge_hi14bit_lo14bit
				    (hi[elm + chunk * 5],
				     lo[elm + chunk * 5]);
				output[ofs + k].af_hpf1 =
				    merge_hi14bit_lo14bit
				    (hi[elm + chunk * 6],
				     lo[elm + chunk * 6]);
				output[ofs + k].af_hpf2 =
				    merge_hi14bit_lo14bit
				    (hi[elm + chunk * 7],
				     lo[elm + chunk * 7]);
			}
			x += chunk;
			rest -= chunk;
		}
	}
}
#endif
hrt_vaddress
sh_css_params_ddr_address_map(void)
{
	return sp_ddr_ptrs;
}

#if !defined(IS_ISP_2500_SYSTEM)
/*
 * @GC:
 */
static void
convert_coords_to_ispparams(
	hrt_vaddress ddr_addr,
	const struct ia_css_dvs_6axis_config *config,
	unsigned int i_stride,
	unsigned int o_width,
	unsigned int o_height,
	unsigned int uv_flag)
{
	unsigned int i, j;
	gdc_warp_param_mem_t s;
	unsigned int x00, x01, x10, x11,
		     y00, y01, y10, y11;

	unsigned int xmin, ymin;
	unsigned int topleft_x, topleft_y,
		     topleft_x_frac, topleft_y_frac;

	/* number of blocks per height and width */
	unsigned int num_blocks_y =  (uv_flag ? DVS_NUM_BLOCKS_Y_CHROMA(o_height) : DVS_NUM_BLOCKS_Y(o_height) );
	unsigned int num_blocks_x =  (uv_flag ? DVS_NUM_BLOCKS_X_CHROMA(o_width)  : DVS_NUM_BLOCKS_X(o_width)  ); // round num_x up to blockdim_x, if it concerns the Y0Y1 block (uv_flag==0) round up to even


	unsigned int in_stride = i_stride * DVS_INPUT_BYTES_PER_PIXEL << uv_flag;
	unsigned width, height;
	unsigned int *xbuff = NULL;
	unsigned int *ybuff = NULL;

	assert(config != NULL);
	assert(ddr_addr != mmgr_NULL);

	ddr_addr += (2* DVS_6AXIS_COORDS_ELEMS * uv_flag); /* format is Y0 Y1 UV, so UV starts at 3rd position */

	if(uv_flag == 0)
	{
		xbuff = config->xcoords_y;
		ybuff = config->ycoords_y;
		width = config->width_y;
		height = config->height_y;
	}
	else
	{
		xbuff = config->xcoords_uv;
		ybuff = config->ycoords_uv;
		width = config->width_uv;
		height = config->height_uv;
	}

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "convert_coords_to_ispparams blockdim_x %d blockdim_y %d\n", DVS_BLOCKDIM_X, DVS_BLOCKDIM_Y_LUMA >> uv_flag);
	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "convert_coords_to_ispparams num_blocks_x %d num_blocks_y %d\n",num_blocks_x,num_blocks_y);
	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "convert_coords_to_ispparams width %d height %d\n",width,height);

	assert(width == num_blocks_x + 1); // the width and height of the provided morphing table should be 1 more than the number of blocks
	assert(height == num_blocks_y + 1);

	for (j = 0; j < num_blocks_y; j++) {
		for (i = 0; i < num_blocks_x; i++) {

			x00 = xbuff[j * width + i];
			x01 = xbuff[j * width + (i+1)];
			x10 = xbuff[(j+1) * width + i];
			x11 = xbuff[(j+1) * width + (i+1)];

			y00 = ybuff[j * width + i];
			y01 = ybuff[j * width + (i+1)];
			y10 = ybuff[(j+1) * width + i];
			y11 = ybuff[(j+1) * width + (i+1)];

			xmin = min(x00, x10);
			ymin = min(y00, y01);

			/* Assert that right column's X is greater */
			assert ( x01 >= xmin);
			assert ( x11 >= xmin);
			/* Assert that bottom row's Y is greater */
			assert ( y10 >= ymin);
			assert ( y11 >= ymin);

#if 0
			/* TODO: Round width to the multiple of bus width */
			xmax = max(x01, x11);
			ymax = max(y10, y11);
			in_block_width  = xmax - xmin;
			in_block_height = ymax - ymin;
#else
			/*
			 * For initial testing, we are using constant input
			 * block size
			 * */
			s.in_block_width  = 128;
			s.in_block_height = 96 >> uv_flag;
#endif

			topleft_y = ymin >> DVS_COORD_FRAC_BITS;
			topleft_x = ((xmin >> DVS_COORD_FRAC_BITS)
					>> XMEM_ALIGN_LOG2)
					<< (XMEM_ALIGN_LOG2);

			s.in_addr_offset = topleft_y * in_stride + topleft_x;

			topleft_x_frac = topleft_x << (DVS_COORD_FRAC_BITS);
			topleft_y_frac = topleft_y << (DVS_COORD_FRAC_BITS);

			s.p0_x = x00 - topleft_x_frac;
			s.p1_x = x01 - topleft_x_frac;
			s.p2_x = x10 - topleft_x_frac;
			s.p3_x = x11 - topleft_x_frac;

			s.p0_y = y00 - topleft_y_frac;
			s.p1_y = y01 - topleft_y_frac;
			s.p2_y = y10 - topleft_y_frac;
			s.p3_y = y11 - topleft_y_frac;

			// block should fit within the boundingbox.
			assert(s.p0_x < (s.in_block_width << DVS_COORD_FRAC_BITS));
			assert(s.p1_x < (s.in_block_width << DVS_COORD_FRAC_BITS));
			assert(s.p2_x < (s.in_block_width << DVS_COORD_FRAC_BITS));
			assert(s.p3_x < (s.in_block_width << DVS_COORD_FRAC_BITS));
			assert(s.p0_y < (s.in_block_height << DVS_COORD_FRAC_BITS));
			assert(s.p1_y < (s.in_block_height << DVS_COORD_FRAC_BITS));
			assert(s.p2_y < (s.in_block_height << DVS_COORD_FRAC_BITS));
			assert(s.p3_y < (s.in_block_height << DVS_COORD_FRAC_BITS));

			// block size should be greater than zero.
			assert(s.p0_x < s.p1_x);
			assert(s.p2_x < s.p3_x);
			assert(s.p0_y < s.p2_y);
			assert(s.p1_y < s.p3_y);
      
#if 0
			printf("j: %d\ti:%d\n", j, i);
			printf("offset: %d\n", s.in_addr_offset);
			printf("p0_x: %d\n", s.p0_x);
			printf("p0_y: %d\n", s.p0_y);
			printf("p1_x: %d\n", s.p1_x);
			printf("p1_y: %d\n", s.p1_y);
			printf("p2_x: %d\n", s.p2_x);
			printf("p2_y: %d\n", s.p2_y);
			printf("p3_x: %d\n", s.p3_x);
			printf("p3_y: %d\n", s.p3_y);

			printf("p0_x_nofrac[0]: %d\n", s.p0_x>>DVS_COORD_FRAC_BITS);
			printf("p0_y_nofrac[1]: %d\n", s.p0_y>>DVS_COORD_FRAC_BITS);
			printf("p1_x_nofrac[2]: %d\n", s.p1_x>>DVS_COORD_FRAC_BITS);
			printf("p1_y_nofrac[3]: %d\n", s.p1_y>>DVS_COORD_FRAC_BITS);
			printf("p2_x_nofrac[0]: %d\n", s.p2_x>>DVS_COORD_FRAC_BITS);
			printf("p2_y_nofrac[1]: %d\n", s.p2_y>>DVS_COORD_FRAC_BITS);
			printf("p3_x_nofrac[2]: %d\n", s.p3_x>>DVS_COORD_FRAC_BITS);
			printf("p3_y_nofrac[3]: %d\n", s.p3_y>>DVS_COORD_FRAC_BITS);
			printf("\n");
#endif

			/* HMM STORE the struct "s" */
			mmgr_store(ddr_addr,
				   (void *)(&s),
				   sizeof(gdc_warp_param_mem_t));

			// storage format:
			// Y0 Y1 UV0 Y2 Y3 UV1
			if (uv_flag)
				ddr_addr += DVS_6AXIS_COORDS_ELEMS * 3;
			else
			    /* increment with 2 incase x is odd, this to
			       skip the uv position. */
				ddr_addr += DVS_6AXIS_COORDS_ELEMS * (1 + (i&1));
		}
	}
}
#endif

#if !defined(IS_ISP_2500_SYSTEM)
static void
store_dvs_6axis_config(
	struct ia_css_isp_parameters *params,
	const struct ia_css_binary *binary,
	hrt_vaddress ddr_addr_y)
{
	unsigned int i_stride;
	unsigned int o_width;
	unsigned int o_height;
	
	assert(params != NULL);
	assert(binary != NULL);
	assert(ddr_addr_y != mmgr_NULL);
	assert(params->dvs_6axis_config != NULL);

	/* bgz115: replaced binary->in_frame_info.res.width for
	   'padded_width=stride' */
	i_stride  = binary->internal_frame_info.padded_width;
	o_width  = binary->out_frame_info.res.width;
	o_height = binary->out_frame_info.res.height;
	
	/* Y plane */
	convert_coords_to_ispparams(ddr_addr_y, params->dvs_6axis_config,
				    i_stride, o_width, o_height, 0);
	/* UV plane (packed inside the y plane) */
	convert_coords_to_ispparams(ddr_addr_y, params->dvs_6axis_config,
				    i_stride/2, o_width/2, o_height/2, 1);


	params->isp_params_changed = true;
}
#endif

#if !defined(IS_ISP_2500_SYSTEM)
/* ****************************************************
 * Each coefficient is stored as 7bits to fit 2 of them into one
 * ISP vector element, so we will store 4 coefficents on every
 * memory word (32bits)
 *
 * 0: Coefficient 0 used bits
 * 1: Coefficient 1 used bits
 * 2: Coefficient 2 used bits
 * 3: Coefficient 3 used bit3
 * x: not used
 *
 * xx33333332222222 | xx11111110000000
 *
 * ***************************************************
 */
static void
store_fpntbl(struct ia_css_isp_parameters *params, hrt_vaddress ptr)
{
	unsigned int i, j;
	short *data_ptr;

	assert(params != NULL);
	assert(ptr != mmgr_NULL);

	data_ptr = params->fpn_config.data;

	for (i = 0; i < params->fpn_config.height; i++) {
		for (j = 0;
		     j < params->fpn_config.width;
		     j += 4, ptr += 4, data_ptr += 4) {
			int data = data_ptr[0] << 0 |
				   data_ptr[1] << 7 |
				   data_ptr[2] << 16 |
				   data_ptr[3] << 23;
			mmgr_store(ptr, (void *)(&data), sizeof(data));
		}
	}
}
#endif

#if !defined(IS_ISP_2500_SYSTEM)
static void
convert_raw_to_fpn(struct ia_css_isp_parameters *params)
{
	short maxval = 0;
	unsigned int i;

	assert(params != NULL);

	/* Find the maximum value in the table */
	for (i = 0; i < params->fpn_config.height * params->fpn_config.width; i++) {
		short val = params->fpn_config.data[i];
		/* Make sure FPN value can be represented in 13-bit unsigned
		 * number (ISP precision - 1), but note that actual input range
		 * depends on precision of input frame data.
		 */
		if (val < 0) {
/* Checkpatch patch */
			val = 0;
		} else if (val >= (1 << 13)) {
/* Checkpatch patch */
/* MW: BUG, is "13" a system or application property */
			val = (1 << 13) - 1;
		}
		maxval = max(maxval, val);
	}
	/* Find the lowest shift value to remap the values in the range
	 * 0..maxval to 0..2^shiftval*63.
	 */
	params->fpn_config.shift = 0;
	while (maxval > 63) {
/* MW: BUG, is "63" a system or application property */
		maxval /= 2;
		params->fpn_config.shift++;
	}
	/* Adjust the values in the table for the shift value */
	for (i = 0; i < params->fpn_config.height * params->fpn_config.width; i++)
		((unsigned short *) params->fpn_config.data)[i] >>= params->fpn_config.shift;
}

static void
ia_css_process_kernel(struct ia_css_stream *stream,
		      struct ia_css_isp_parameters *params,
		      void (*process)(unsigned pipe_id,
				      const struct ia_css_pipeline_stage *stage,
				      struct ia_css_isp_parameters *params))
{
	int i;
	for (i = 0; i < stream->num_pipes; i++) {
		struct ia_css_pipe *pipe = stream->pipes[i];
		struct ia_css_pipeline *pipeline= ia_css_pipe_get_pipeline(pipe);
		struct ia_css_pipeline_stage *stage;

		/* update the other buffers to the pipe specific copies */
		for (stage = pipeline->stages; stage; stage = stage->next) {
			if (!stage || !stage->binary) continue;
			process(pipeline->pipe_id, stage, params);
		}
	}
}

#endif

enum ia_css_err
sh_css_set_black_frame(struct ia_css_stream *stream,
	const struct ia_css_frame *raw_black_frame)
{
	struct ia_css_isp_parameters *params;
	/* this function desperately needs to be moved to the ISP or SP such
	 * that it can use the DMA.
	 */
	unsigned int height, width, y, x, k, data;
	hrt_vaddress ptr;

	assert(stream != NULL);
	assert(raw_black_frame != NULL);

	params = stream->isp_params_configs;
	height = raw_black_frame->info.res.height;
	width = raw_black_frame->info.padded_width,

	ptr = raw_black_frame->data
		+ raw_black_frame->planes.raw.offset;

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_set_black_frame() enter: \
		black_frame=%p\n",raw_black_frame);

#if defined(IS_ISP_2500_SYSTEM)
	(void)ptr;
	(void)data;
	(void)k;
	(void)x;
	(void)y;
	(void)width;
	(void)height;
	(void)params;
#else
	if (params->fpn_config.data &&
	    (params->fpn_config.width != width || params->fpn_config.height != height)) {
		sh_css_free(params->fpn_config.data);
		params->fpn_config.data = NULL;
	}
	if (params->fpn_config.data == NULL) {
		params->fpn_config.data = sh_css_malloc(height * width * sizeof(short));
		if (!params->fpn_config.data) {
	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_set_black_frame() leave: \
		return_err=%d\n",IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY);
			return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
		}
		params->fpn_config.width = width;
		params->fpn_config.height = height;
		params->fpn_config.shift = 0;
	}

	/* store raw to fpntbl */
	for (y = 0; y < height; y++) {
		for (x = 0; x < width; x += (ISP_VEC_NELEMS * 2)) {
			int ofs = y * width + x;
			for (k = 0; k < ISP_VEC_NELEMS; k += 2) {
				mmgr_load(ptr, (void *)(&data), sizeof(int));
				params->fpn_config.data[ofs + 2 * k] =
				    (short) (data & 0xFFFF);
				params->fpn_config.data[ofs + 2 * k + 2] =
				    (short) ((data >> 16) & 0xFFFF);
				ptr += sizeof(int);	/* byte system address */
			}
			for (k = 0; k < ISP_VEC_NELEMS; k += 2) {
				mmgr_load(ptr, (void *)(&data), sizeof(int));
				params->fpn_config.data[ofs + 2 * k + 1] =
				    (short) (data & 0xFFFF);
				params->fpn_config.data[ofs + 2 * k + 3] =
				    (short) ((data >> 16) & 0xFFFF);
				ptr += sizeof(int);	/* byte system address */
			}
		}
	}

	/* raw -> fpn */
	convert_raw_to_fpn(params);

	/* overwrite isp parameter */
	ia_css_process_kernel(stream, params, ia_css_kernel_process_param[IA_CSS_FPN_ID]);
#endif

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_set_black_frame() leave: \
		return_err=%d\n",IA_CSS_SUCCESS);

	return IA_CSS_SUCCESS;
}

bool
sh_css_params_set_binning_factor(struct ia_css_stream *stream, unsigned int binning_fact)
{
	struct ia_css_isp_parameters *params;
	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_params_set_binning_factor() enter:\n");

	assert(stream != NULL);

	params = stream->isp_params_configs;

	if (params->sensor_binning != binning_fact) {
		params->sensor_binning = binning_fact;
		params->sc_table_changed = true;
	}

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_params_set_binning_factor() leave:\n");

	return params->sc_table_changed;
}

#if !defined(IS_ISP_2500_SYSTEM)
static void
sh_css_set_shading_table(struct ia_css_stream *stream,
			 const struct ia_css_shading_table *table)
{
	struct ia_css_isp_parameters *params;
	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_set_shading_table() enter:\n");

	if (table == NULL)
		return;
	assert(stream != NULL);

	params = stream->isp_params_configs;

	if (!table->enable)
		table = NULL;

	if (table != params->sc_table) {
		params->sc_table = table;
		params->sc_table_changed = true;
		/* Not very clean, this goes to sh_css.c to invalidate the
		 * shading table for all pipes. Should replaced by a loop
		 * and a pipe-specific call.
		 */
		sh_css_invalidate_shading_tables(stream);
	}

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_set_shading_table() leave:\n");
}
#endif

#if !defined(IS_ISP_2500_SYSTEM)
static void
store_sctbl(
	    const struct ia_css_pipeline_stage *stage,
	    hrt_vaddress ddr_addr,
	    const struct ia_css_shading_table *shading_table)
{
	const struct ia_css_binary *binary = stage->binary;
	unsigned int i, j, aligned_width, row_padding;

	assert(binary != NULL);
	assert(shading_table != NULL);
	assert(ddr_addr != mmgr_NULL);

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "store_sctbl() enter:\n");

	if (shading_table == NULL) {
/* Checkpatch patch */
	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "store_sctbl() leave:\n");
		return;
	}

	aligned_width = binary->sctbl_aligned_width_per_color;
	row_padding = aligned_width - shading_table->width;

	for (i = 0; i < shading_table->height; i++) {
		for (j = 0; j < IA_CSS_SC_NUM_COLORS; j++) {
			mmgr_store(ddr_addr,
				   &shading_table->data[j]
					[i*shading_table->width],
				   shading_table->width * sizeof(short));
			ddr_addr += shading_table->width * sizeof(short);
			mmgr_clear(ddr_addr,
				   row_padding * sizeof(short));
			ddr_addr += row_padding * sizeof(short);
		}
	}

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "store_sctbl() leave:\n");
}
#endif

#if !defined(IS_ISP_2500_SYSTEM)
static void
sh_css_enable_pipeline(const struct ia_css_binary *binary)
{
	if (!binary) return;

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_enable_pipeline() enter:\n");

	ia_css_isp_param_enable_pipeline(&binary->mem_params);

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_enable_pipeline() leave:\n");
}
#endif

#if !defined(IS_ISP_2500_SYSTEM)
static void ia_css_process_zoom_and_motion(
	struct ia_css_isp_parameters *params,
	enum ia_css_pipe_id pipe_id,
	const struct ia_css_pipeline_stage *first_stage)
{
	/* first_stage can be  NULL */
	const struct ia_css_pipeline_stage *stage;

	assert(params != NULL);

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_zoom_and_motion() enter:\n");

	/* Go through all stages to udate uds and cropping */
	for (stage = first_stage; stage; stage = stage->next) {

		struct ia_css_binary *binary;
		struct ia_css_binary tmp_binary;

		const struct ia_css_binary_xinfo *info = NULL;

		binary = stage->binary;
		if (binary) {
			info = binary->info;
		} else {
			const struct sh_css_binary_args *args = &stage->args;
			info = &stage->firmware->info.isp;
			ia_css_binary_fill_info(info, false, false,
				IA_CSS_STREAM_FORMAT_RAW_10,
				args->in_frame  ? &args->in_frame->info  : NULL,
				NULL,
				args->out_frame ? &args->out_frame->info : NULL,
				args->out_vf_frame ? &args->out_vf_frame->info
									: NULL,
				&tmp_binary,
				NULL,
				-1);
			binary = &tmp_binary;
			binary->info = info;
		}

		assert(stage->stage_num < SH_CSS_MAX_STAGES);
		sh_css_update_uds_and_crop_info(
			&info->sp,
			&binary->in_frame_info,
			&binary->out_frame_info,
			&binary->dvs_envelope,
			pipe_id == IA_CSS_PIPE_ID_PREVIEW,
			&params->dz_config,
			&params->motion_config,
			&params->uds[stage->stage_num].uds,
			&params->uds[stage->stage_num].crop_pos);
	}
	params->isp_params_changed = true;

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ia_css_process_zoom_and_motion() leave:\n");
}
#endif

#if !defined(IS_ISP_2500_SYSTEM)
static void
sh_css_set_gamma_table(struct ia_css_isp_parameters *params,
			const struct ia_css_gamma_table *table)
{
	if (table == NULL)
		return;
	assert(params != NULL);

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_set_gamma_table() enter: "
			    "table=%p\n", table);

	assert(params != NULL);
	assert(table != NULL);

	params->gc_table = *table;
	params->config_changed[IA_CSS_GC_ID] = true;

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_set_gamma_table() leave: "
		"return_void\n");
}
#endif

#if !defined(IS_ISP_2500_SYSTEM)
static void
sh_css_get_gamma_table(const struct ia_css_isp_parameters *params,
			struct ia_css_gamma_table *table)
{
	if (table == NULL)
		return;
	assert(params != NULL);

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_get_gamma_table() enter: "
		"table=%p\n", table);

	*table = params->gc_table;

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_get_gamma_table() leave: "
		"return_void\n");
}
#endif

#if !defined(IS_ISP_2500_SYSTEM)
static void
sh_css_set_ctc_table(struct ia_css_isp_parameters *params,
			const struct ia_css_ctc_table *table)
{
	if (table == NULL)
		return;
	assert(params != NULL);

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_set_ctc_table() enter: "
		"table=%p\n", table);

	params->ctc_table = *table;
	params->config_changed[IA_CSS_CTC_ID] = true;

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_set_ctc_table() leave: "
		"return_void\n");
}
#endif

#if !defined(IS_ISP_2500_SYSTEM)
static void
sh_css_get_ctc_table(const struct ia_css_isp_parameters *params,
			struct ia_css_ctc_table *table)
{
	if (table == NULL)
		return;
	assert(params != NULL);

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_get_ctc_table() enter: "
		"table=%p\n", table);

	*table = params->ctc_table;

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_get_ctc_table() leave: "
		"return_void\n");
}
#endif

#if !defined(IS_ISP_2500_SYSTEM)
static void
sh_css_set_macc_table(struct ia_css_isp_parameters *params,
			const struct ia_css_macc_table *table)
{
	if (table == NULL)
		return;
	assert(params != NULL);

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_set_macc_table() enter: "
		"table=%p\n", table);

	params->macc_table = *table;
	params->config_changed[IA_CSS_MACC_ID] = true;

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_set_macc_table() leave: "
		"return_void\n");
}
#endif

#if !defined(IS_ISP_2500_SYSTEM)
static void
sh_css_get_macc_table(const struct ia_css_isp_parameters *params,
			struct ia_css_macc_table *table)
{
	if (table == NULL)
		return;
	assert(params != NULL);

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_get_macc_table() enter: "
		"table=%p\n", table);

	*table = params->macc_table;

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_get_macc_table() leave: "
		"return_void\n");
}
#endif

#if !defined(IS_ISP_2500_SYSTEM)
static void
sh_css_set_anr_thres(struct ia_css_isp_parameters *params,
			const struct ia_css_anr_thres *thres)
{
	if (thres == NULL)
		return;
	assert(params != NULL);

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_set_anr_thres() enter: "
		"thres=%p\n",thres);

	params->anr_thres = *thres;
	params->anr_thres_changed = true;

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_set_anr_thres() leave: "
		"return_void\n");
}
#endif

#if !defined(IS_ISP_2500_SYSTEM)
static void
sh_css_get_anr_thres(const struct ia_css_isp_parameters *params,
			struct ia_css_anr_thres *thres)
{
	if (thres == NULL)
		return;
	assert(params != NULL);

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_get_anr_thres() enter: "
		"thres=%p\n",thres);

	*thres = params->anr_thres;

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_get_anr_thres() leave: "
		"return_void\n");
}
#endif

#if !defined(IS_ISP_2500_SYSTEM)
void ia_css_morph_table_free(
	struct ia_css_morph_table *me)
{
	unsigned int i;

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_morph_table_free() enter:\n");

	if (me == NULL) {
		return;
	}

	for (i = 0; i < IA_CSS_MORPH_TABLE_NUM_PLANES; i++) {
		if (me->coordinates_x[i])
			sh_css_free(me->coordinates_x[i]);
		if (me->coordinates_y[i])
			sh_css_free(me->coordinates_y[i]);
	}

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_morph_table_free() leave:\n");

	sh_css_free(me);
}
#endif

#if !defined(IS_ISP_2500_SYSTEM)
struct ia_css_morph_table *ia_css_morph_table_allocate(
	unsigned int width,
	unsigned int height)
{
	unsigned int i;
	struct ia_css_morph_table *me = sh_css_malloc(sizeof(*me));

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_morph_table_allocate() enter:\n");

	if (me == NULL) {
		return me;
	}

	for (i = 0; i < IA_CSS_MORPH_TABLE_NUM_PLANES; i++) {
		me->coordinates_x[i] = NULL;
		me->coordinates_y[i] = NULL;
	}

	for (i = 0; i < IA_CSS_MORPH_TABLE_NUM_PLANES; i++) {
		me->coordinates_x[i] =
		    sh_css_malloc(height * width *
				  sizeof(*me->coordinates_x[i]));
		me->coordinates_y[i] =
		    sh_css_malloc(height * width *
				  sizeof(*me->coordinates_y[i]));

		if ((me->coordinates_x[i] == NULL) ||
			(me->coordinates_y[i] == NULL)) {
			ia_css_morph_table_free(me);
			me = NULL;
			return me;
		}
	}
	me->width = width;
	me->height = height;

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_morph_table_allocate() leave:\n");

	return me;
}
#endif

#if !defined(IS_ISP_2500_SYSTEM)
static enum ia_css_err sh_css_params_default_morph_table(
	struct ia_css_morph_table **table,
	const struct ia_css_binary *binary)
{
/* MW 2400 advanced requires different scaling */
	unsigned int i, j, k, step, width, height;
	short start_x[IA_CSS_MORPH_TABLE_NUM_PLANES] = { -8, 0, -8, 0, 0, -8 },
	      start_y[IA_CSS_MORPH_TABLE_NUM_PLANES] = { 0, 0, -8, -8, -8, 0 };
	struct ia_css_morph_table *tab;

	assert(table != NULL);
	assert(binary != NULL);

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_params_default_morph_table() enter:\n");

	step = (ISP_VEC_NELEMS / 16) * 128,
	width = binary->morph_tbl_width,
	height = binary->morph_tbl_height;

	tab = ia_css_morph_table_allocate(width, height);
	if (tab == NULL) {

		return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
	}

	for (i = 0; i < IA_CSS_MORPH_TABLE_NUM_PLANES; i++) {
		short val_y = start_y[i];
		for (j = 0; j < height; j++) {
			short val_x = start_x[i];
			unsigned short *x_ptr, *y_ptr;

			x_ptr = &tab->coordinates_x[i][j * width];
			y_ptr = &tab->coordinates_y[i][j * width];
			for (k = 0; k < width;
			     k++, x_ptr++, y_ptr++, val_x += (short)step) {
				if (k == 0)
					*x_ptr = 0;
				else if (k == width - 1)
					*x_ptr = val_x + 2 * start_x[i];
				else
					*x_ptr = val_x;
				if (j == 0)
					*y_ptr = 0;
				else
					*y_ptr = val_y;
			}
			val_y += (short)step;
		}
	}
	*table = tab;

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_params_default_morph_table() leave:\n");

	return IA_CSS_SUCCESS;
}
#endif

#if !defined(IS_ISP_2500_SYSTEM)
static void
sh_css_set_morph_table(struct ia_css_isp_parameters *params,
			const struct ia_css_morph_table *table)
{
	if (table == NULL)
		return;
	assert(params != NULL);

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_set_morph_table() enter: "
		"table=%p\n", table);

	if (table->enable == false)
		table = NULL;
	params->morph_table = table;
	params->morph_table_changed = true;
	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_set_morph_table() leave: "
		"return_void\n");
}
#if 0
/* TODO: connect this properly. The table would have to be copied
 * out.
 * */
static void
sh_css_get_morph_table(struct ia_css_isp_parameters *params,
			const struct ia_css_morph_table **table)
{
	if (table == NULL)
		return;
	assert(params != NULL);

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_get_morph_table() enter: "
		"table=%p\n", table);

	*table = params->morph_table;

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_get_morph_table() leave: "
		"return_void\n");
}
#endif
#endif


#if defined(IS_ISP_2500_SYSTEM)
void
ia_css_get_4a_statistics(struct ia_css_4a_statistics *host_stats,
		const struct ia_css_isp_3a_statistics *isp_stats)
{
	int i , num_sets,size_of_set,index=0;

	af_private_config_t		af_acc_cfg;
	awb_fr_private_config_t		awb_fr_acc_cfg;
	ae_private_direct_config_t	ae_acc_grd_cfg;
	awb_private_config_t		awb_acc_grd_cfg;

	hrt_vaddress af_ddr_addr = (hrt_vaddress)(long int)&(((struct stats_4a_private_raw_buffer*)(long int)isp_stats->data.dmem.s3a_tbl)->af_raw_buffer);
	hrt_vaddress awb_ddr_addr = (hrt_vaddress)(long int)&((struct stats_4a_private_raw_buffer*)(long int)isp_stats->data.dmem.s3a_tbl)->awb_raw_buffer;
	hrt_vaddress ae_ddr_addr = (hrt_vaddress)(long int)&((struct stats_4a_private_raw_buffer*)(long int)isp_stats->data.dmem.s3a_tbl)->ae_raw_buffer;
	hrt_vaddress awb_fr_ddr_addr = (hrt_vaddress)(long int)&((struct stats_4a_private_raw_buffer*)(long int)isp_stats->data.dmem.s3a_tbl)->awb_fr_raw_buffer;

	hrt_vaddress af_cfg_ddr_addr = (hrt_vaddress)(long int)&((struct stats_4a_private_raw_buffer*)(long int)isp_stats->data.dmem.s3a_tbl)->af_config;
	hrt_vaddress awb_fr_cfg_ddr_addr = (hrt_vaddress)(long int)&((struct stats_4a_private_raw_buffer*)(long int)isp_stats->data.dmem.s3a_tbl)->awb_fr_config;
	hrt_vaddress ae_cfg_ddr_addr = (hrt_vaddress)(long int)&((struct stats_4a_private_raw_buffer*)(long int)isp_stats->data.dmem.s3a_tbl)->ae_grd_config;
	hrt_vaddress awb_cfg_ddr_addr = (hrt_vaddress)(long int)&((struct stats_4a_private_raw_buffer*)(long int)isp_stats->data.dmem.s3a_tbl)->awb_config;

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
			"ia_css_get_4a_statistics() enter: "
			"host_stats=%p, isp_stats=%p\n",
			host_stats, isp_stats);
	

		mmgr_load(af_ddr_addr,
					(void*)&(host_stats->data->af_raw_buffer),
					sizeof(af_public_raw_buffer_t));
		mmgr_load(awb_ddr_addr,
					(void*)&(host_stats->data->awb_raw_buffer),
					sizeof(awb_public_raw_buffer_t));
		mmgr_load(ae_ddr_addr,
					(void*)&(host_stats->data->ae_raw_buffer),
					 sizeof(ae_public_raw_buffer_t));
		mmgr_load(awb_fr_ddr_addr,
					(void*)&(host_stats->data->awb_fr_raw_buffer),
					 sizeof(awb_fr_public_raw_buffer_t));


		//Load configuration
		mmgr_load(af_cfg_ddr_addr,
							(void*)&(af_acc_cfg),
							 sizeof(af_private_config_t));
		mmgr_load(awb_fr_cfg_ddr_addr,
							(void*)&(awb_fr_acc_cfg),
							 sizeof(awb_fr_private_config_t));
		mmgr_load(ae_cfg_ddr_addr,
							(void*)&(ae_acc_grd_cfg),
							 sizeof(ae_private_direct_config_t));
		mmgr_load(awb_cfg_ddr_addr,
								(void*)&(awb_acc_grd_cfg),
								 sizeof(awb_private_config_t));

		/* Translate between private and public
		 * TODO - make this more general, redefine the structs */

		host_stats->stats_4a_config->af_grd_config.grid_width		= (unsigned char)af_acc_cfg.ff_af_config.y_grid_config.grd_cfg.grid_width;
		host_stats->stats_4a_config->af_grd_config.grid_height	 	= (unsigned char)af_acc_cfg.ff_af_config.y_grid_config.grd_cfg.grid_height;
		host_stats->stats_4a_config->af_grd_config.x_start 			= (unsigned short)af_acc_cfg.ff_af_config.y_grid_config.grd_start.x_start;
		host_stats->stats_4a_config->af_grd_config.y_start			= (unsigned short)af_acc_cfg.ff_af_config.y_grid_config.grd_start.y_start;
		host_stats->stats_4a_config->af_grd_config.block_width	 	= (unsigned char)af_acc_cfg.ff_af_config.y_grid_config.grd_cfg.block_width;
		host_stats->stats_4a_config->af_grd_config.block_height		= (unsigned char)af_acc_cfg.ff_af_config.y_grid_config.grd_cfg.block_height;


		host_stats->stats_4a_config->awb_fr_grd_config.grid_width	= (unsigned char)awb_fr_acc_cfg.bayer_config.BAYER_GRD_CFG_Info_t.grid_width;
		host_stats->stats_4a_config->awb_fr_grd_config.grid_height	= (unsigned char)awb_fr_acc_cfg.bayer_config.BAYER_GRD_CFG_Info_t.grid_height;
		host_stats->stats_4a_config->awb_fr_grd_config.x_start		= (unsigned short)awb_fr_acc_cfg.bayer_config.BAYER_GRD_START_Info_t.x_start;
		host_stats->stats_4a_config->awb_fr_grd_config.y_start		= (unsigned short)awb_fr_acc_cfg.bayer_config.BAYER_GRD_START_Info_t.y_start;
		host_stats->stats_4a_config->awb_fr_grd_config.block_width	= (unsigned char)awb_fr_acc_cfg.bayer_config.BAYER_GRD_CFG_Info_t.block_width;
		host_stats->stats_4a_config->awb_fr_grd_config.block_height = (unsigned char)awb_fr_acc_cfg.bayer_config.BAYER_GRD_CFG_Info_t.block_height;

		host_stats->stats_4a_config->ae_grd_config.grid_height 		= ae_acc_grd_cfg.grid_height;
		host_stats->stats_4a_config->ae_grd_config.grid_width  		= ae_acc_grd_cfg.grid_width;
		host_stats->stats_4a_config->ae_grd_config.x_start  		= ae_acc_grd_cfg.x_start;
		host_stats->stats_4a_config->ae_grd_config.y_start		    = ae_acc_grd_cfg.y_start;
		host_stats->stats_4a_config->ae_grd_config.block_width		= ae_acc_grd_cfg.block_width;
		host_stats->stats_4a_config->ae_grd_config.block_height		= ae_acc_grd_cfg.block_height;

		host_stats->stats_4a_config->awb_grd_config.grid_height 	  = (unsigned char)awb_acc_grd_cfg.rgbs_grd_cfg.grid_height;
		host_stats->stats_4a_config->awb_grd_config.grid_width  	  = (unsigned char)awb_acc_grd_cfg.rgbs_grd_cfg.grid_width;
		host_stats->stats_4a_config->awb_grd_config.grid_x_start	  = awb_acc_grd_cfg.rgbs_grd_start.x_start;
		host_stats->stats_4a_config->awb_grd_config.grid_y_start	  = awb_acc_grd_cfg.rgbs_grd_start.y_start;
		host_stats->stats_4a_config->awb_grd_config.grid_block_width  = (unsigned char)awb_acc_grd_cfg.rgbs_grd_cfg.block_width;
		host_stats->stats_4a_config->awb_grd_config.grid_block_height = (unsigned char)awb_acc_grd_cfg.rgbs_grd_cfg.block_height;


		/* Debubble -  removes bubbles between sets of statistics for AWB, AWB_FR, AF caused by the ACC */
		/**** AF ****/

		if(host_stats->stats_4a_config->af_grd_config.grid_width) //Avoid division with 0
		{
			if(MAX_SIZE_OF_SET_AF % host_stats->stats_4a_config->af_grd_config.grid_width)
			{
				size_of_set = index =  (MAX_SIZE_OF_SET_AF / host_stats->stats_4a_config->af_grd_config.grid_width)* host_stats->stats_4a_config->af_grd_config.grid_width; //This removes the remainder
				num_sets = (host_stats->stats_4a_config->af_grd_config.grid_width * host_stats->stats_4a_config->af_grd_config.grid_height) / size_of_set;
				for(i=0; i < num_sets;i++)
				{
					memcpy((void *)&host_stats->data->af_raw_buffer.y_table[index],(void *)&host_stats->data->af_raw_buffer.y_table[(i+1)*MAX_SIZE_OF_SET_AF],sizeof(af_public_y_item_t)*size_of_set);
					index += size_of_set;
				}
			}
		}

		/**** AWB_FR ****/

		if(host_stats->stats_4a_config->awb_fr_grd_config.grid_width) //Avoid division with 0
		{
			if(MAX_SIZE_OF_SET_AWB_FR % host_stats->stats_4a_config->awb_fr_grd_config.grid_width)
			{

				size_of_set = index =  (MAX_SIZE_OF_SET_AWB_FR / host_stats->stats_4a_config->awb_fr_grd_config.grid_width) * host_stats->stats_4a_config->awb_fr_grd_config.grid_width; //This removes the remainder
				num_sets = (host_stats->stats_4a_config->awb_fr_grd_config.grid_width * host_stats->stats_4a_config->awb_fr_grd_config.grid_height) / size_of_set;
				for(i=0; i < num_sets;i++)
				{
					memcpy((void*)&host_stats->data->awb_fr_raw_buffer.bayer_table[index],(void *)&host_stats->data->awb_fr_raw_buffer.bayer_table[(i+1)*MAX_SIZE_OF_SET_AWB_FR],sizeof(awb_fr_public_bayer_item_t)*size_of_set);
					index += size_of_set;
				}

			}
		}


		/**** AWB ****/
		if(host_stats->stats_4a_config->awb_grd_config.grid_width) //Avoid division with 0
		{
			if(MAX_SIZE_OF_SET_AWB % host_stats->stats_4a_config->awb_grd_config.grid_width )
			{
				size_of_set = index = (MAX_SIZE_OF_SET_AWB / 	host_stats->stats_4a_config->awb_grd_config.grid_width)  * 	host_stats->stats_4a_config->awb_grd_config.grid_width; //This removes the remainder
				num_sets = (	host_stats->stats_4a_config->awb_grd_config.grid_width * 	host_stats->stats_4a_config->awb_grd_config.grid_height) / size_of_set ;
				for(i=0; i < num_sets;i++)
				{
					memcpy((void *)&host_stats->data->awb_raw_buffer.rgb_table[index],(void *)&host_stats->data->awb_raw_buffer.rgb_table[(i+1)*MAX_SIZE_OF_SET_AWB],sizeof(awb_public_set_item_t)*size_of_set);
					index += size_of_set;

				}
			}
		}

		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
				"ia_css_get_4a_statistics() leave: return_void\n");
		

}
#endif

#if !defined(SYSTEM_css_skycam_a0t_system)
void
ia_css_get_3a_statistics(struct ia_css_3a_statistics           *host_stats,
			 const struct ia_css_isp_3a_statistics *isp_stats)
{
	assert(host_stats != NULL);
	assert(isp_stats != NULL);

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
		"ia_css_get_3a_statistics() enter: "
		"host_stats=%p, isp_stats=%p\n",
		host_stats, isp_stats);

	if (host_stats->grid.use_dmem) {
		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "3A: DMEM\n");
		get_3a_stats_from_dmem(host_stats,
				       isp_stats->data.dmem.s3a_tbl);
	} else {
		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "3A: VMEM\n");
		get_3a_stats_from_vmem(host_stats,
				       isp_stats->data.vmem.s3a_tbl_hi,
				       isp_stats->data.vmem.s3a_tbl_lo);
	}
#if !defined(HAS_NO_HMEM) && !defined(SYSTEM_css_skycam_a0t_system)
	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "3A: HMEM\n");
	get_3a_stats_from_hmem(host_stats,
			       isp_stats->data_hmem.rgby_tbl);
#endif

#if 0
	/* The code below is written to dump the host_stats.
	 * It is not intended to be used in daily operation
	 * but it might be useful to debug problems so it is
	 * proposed to leave it in
	 */
	{
		int w, h;
		int width = host_stats->grid.width;
		int height = host_stats->grid.height;

		for (h = 0; h < height; h++)
		{
			for (w = 0; w < width; w++)
			{
				ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "3A: (%2d,%2d) %10d %10d %10d %10d %10d\n",
						h, w,
						host_stats->data[h*width + w].awb_r,
						host_stats->data[h*width + w].awb_gr,
						host_stats->data[h*width + w].awb_gb,
						host_stats->data[h*width + w].awb_b,
						host_stats->data[h*width + w].awb_cnt);
			}
		}
	}
#endif
	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
		"ia_css_get_3a_statistics() leave: return_void\n");
}
#endif

#if !defined(IS_ISP_2500_SYSTEM)
/* Parameter encoding is not yet orthogonal.
   This function hnadles some of the exceptions.
*/
static void
ia_css_set_param_exceptions(struct ia_css_isp_parameters *params)
{
	assert (params != NULL);

	/* Copy also to DP. Should be done by the driver. */
	params->dp_config.gr = params->wb_config.gr;
	params->dp_config.r  = params->wb_config.r;
	params->dp_config.b  = params->wb_config.b;
	params->dp_config.gb = params->wb_config.gb;
}
#endif

#if !defined(IS_ISP_2500_SYSTEM)
static void
sh_css_set_nr_config(struct ia_css_isp_parameters *params,
			const struct ia_css_nr_config *config)
{
	if (config == NULL)
		return;
	assert(params != NULL);

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_set_nr_config() enter: ");
	ia_css_nr_debug_dtrace(config, IA_CSS_DEBUG_TRACE_PRIVATE);
	params->nr_config = *config;
	params->yee_config.nr = *config;
	params->config_changed[IA_CSS_NR_ID]  = true;
	params->config_changed[IA_CSS_YEE_ID] = true;
	params->config_changed[IA_CSS_BNR_ID] = true;

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
		"sh_css_set_nr_config() leave: "
		"return_void\n");
}
#endif

#if !defined(IS_ISP_2500_SYSTEM)
static void
sh_css_set_ee_config(struct ia_css_isp_parameters *params,
			const struct ia_css_ee_config *config)
{
	if (config == NULL)
		return;
	assert(params != NULL);

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_set_ee_config() enter: ");
	ia_css_ee_debug_dtrace(config, IA_CSS_DEBUG_TRACE_PRIVATE);
	params->ee_config = *config;
	params->yee_config.ee = *config;
	params->config_changed[IA_CSS_YEE_ID] = true;

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
		"sh_css_set_ee_config() leave: "
		"return_void\n");
}
#endif

#if !defined(IS_ISP_2500_SYSTEM)
static void
sh_css_get_ee_config(const struct ia_css_isp_parameters *params,
			struct ia_css_ee_config *config)
{
	if (config == NULL)
		return;
	assert(params != NULL);

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_get_ee_config() enter: "
		"config=%p\n",config);

	*config = params->ee_config;
	
	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_get_ee_config() enter: ");
	ia_css_ee_debug_dtrace(config, IA_CSS_DEBUG_TRACE_PRIVATE);
}
#endif

#if !defined(IS_ISP_2500_SYSTEM)
static void
sh_css_set_dvs_6axis_config(struct ia_css_isp_parameters *params,
			   const struct ia_css_dvs_6axis_config  *dvs_config)
{
	if (dvs_config == NULL)
		return;
	assert(params != NULL);
	assert(dvs_config->height_y == dvs_config->height_uv);
	assert( (dvs_config->width_y - 1) == 2 * (dvs_config->width_uv - 1));

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_set_dvs_config() enter: "
	"dvs_config=%p\n",dvs_config);

	copy_dvs_6axis_table(params->dvs_6axis_config,dvs_config);
	
	params->dvs_6axis_config_changed = true;	
	
	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
		"sh_css_set_dvs_6axis_config() leave: "
		"return_void\n");

}
#endif

#if !defined(IS_ISP_2500_SYSTEM)
static void
sh_css_get_dvs_6axis_config(const struct ia_css_isp_parameters *params,
				struct ia_css_dvs_6axis_config *dvs_config)
{
	if (dvs_config == NULL)
		return;
	assert(params != NULL);
	assert(dvs_config->height_y == dvs_config->height_uv);
	assert( (dvs_config->width_y - 1) == 2 * dvs_config->width_uv - 1);

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_get_dvs_6axis_config() enter: "
		"dvs_config=%p\n",dvs_config);

	if ((dvs_config->width_y == params->dvs_6axis_config->width_y) &&
	    (dvs_config->height_y == params->dvs_6axis_config->height_y) &&
	    (dvs_config->width_uv == params->dvs_6axis_config->width_uv) &&
	    (dvs_config->height_uv == params->dvs_6axis_config->height_uv) &&
	     dvs_config->xcoords_y &&
	     dvs_config->ycoords_y &&
	     dvs_config->xcoords_uv &&
	     dvs_config->ycoords_uv)
	{
		copy_dvs_6axis_table(dvs_config,params->dvs_6axis_config);
	}
	
	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
		"sh_css_get_dvs_6axis_config() leave: "
		"return_void\n");
}
#endif

#if !defined(IS_ISP_2500_SYSTEM)
static void
sh_css_set_baa_config(struct ia_css_isp_parameters *params,
			const struct ia_css_aa_config *config)
{
	if (config == NULL)
		return;
	assert(params != NULL);

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_set_baa_config() enter: ");
	ia_css_aa_debug_dtrace(config, IA_CSS_DEBUG_TRACE);

	params->raw_config = *config;
	params->config_changed[IA_CSS_RAW_ID] = true;

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
		"sh_css_set_baa_config() leave: "
		"return_void\n");
}
#endif

#if !defined(IS_ISP_2500_SYSTEM)
static void
sh_css_get_baa_config(const struct ia_css_isp_parameters *params,
			struct ia_css_aa_config *config)
{
	if (config == NULL)
		return;
	assert(params != NULL);

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_get_baa_config() enter: "
		"config=%p\n",config);

	*config = params->raw_config;

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_get_baa_config() leave: ");
	ia_css_aa_debug_dtrace(config, IA_CSS_DEBUG_TRACE);
}
#endif

#if !defined(IS_ISP_2500_SYSTEM)
static void
sh_css_set_dz_config(struct ia_css_isp_parameters *params,
			const struct ia_css_dz_config *config)
{
	if (config == NULL)
		return;
	assert(params != NULL);

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
		"sh_css_set_zoom_factor() enter: dx=%d, dy=%d\n",
		config->dx, config->dy);

	assert(config->dx <= HRT_GDC_N);
	assert(config->dy <= HRT_GDC_N);

	params->dz_config = *config;
	params->dz_config_changed = true;
	/* JK: Why isp params changed?? */
	params->isp_params_changed = true;

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
		"sh_css_set_zoom_factor() leave: "
		"return_void\n");
}
#endif

#if !defined(IS_ISP_2500_SYSTEM)
static void
sh_css_get_dz_config(const struct ia_css_isp_parameters *params,
			struct ia_css_dz_config *config)
{
	if (config == NULL)
		return;
	assert(params != NULL);

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_get_dz_config() enter:\n");

	*config = params->dz_config;

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
		"sh_css_get_dz_config() leave: dx=%d, dy=%d\n",
		config->dx, config->dy);
}
#endif

#if !defined(IS_ISP_2500_SYSTEM)
static void
sh_css_set_motion_vector(struct ia_css_isp_parameters *params,
			const struct ia_css_vector *motion)
{
	if (motion == NULL)
		return;
	assert(params != NULL);

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
		"sh_css_set_motion_vector() enter: x=%d, y=%d\n",
		motion->x, motion->y);

	params->motion_config = *motion;
	/* JK: Why do isp params change? */
	params->motion_config_changed = true;
	params->isp_params_changed = true;

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
		"sh_css_set_motion_vector() leave: "
		"return_void\n");
}
#endif

#if !defined(IS_ISP_2500_SYSTEM)
static void
sh_css_get_motion_vector(const struct ia_css_isp_parameters *params,
			struct ia_css_vector *motion)
{
	if (motion == NULL)
		return;
	assert(params != NULL);

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_get_motion_vector() enter\n");

	*motion = params->motion_config;

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
		"sh_css_get_motion_vector() leave: x=%d, y=%d\n",
		motion->x, motion->y);
}
#endif

enum ia_css_err
ia_css_stream_set_isp_config(
	struct ia_css_stream *stream,
	const struct ia_css_isp_config *config)
{
	return ia_css_stream_set_isp_config_on_pipe(stream, config, NULL);
}

enum ia_css_err
ia_css_stream_set_isp_config_on_pipe(
	struct ia_css_stream *stream,
	const struct ia_css_isp_config *config,
	struct ia_css_pipe *pipe)
{
	struct ia_css_isp_parameters *params;

	if ((stream == NULL) || (config == NULL))
		return IA_CSS_ERR_INVALID_ARGUMENTS;

	params = stream->isp_params_configs;

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_set_isp_config() enter: "
		"stream=%p, config=%p\n", stream, config);

#if !defined(IS_ISP_2500_SYSTEM)
	sh_css_set_nr_config(params, config->nr_config);
	sh_css_set_ee_config(params, config->ee_config);
	sh_css_set_baa_config(params, config->baa_config);
	sh_css_set_dvs_6axis_config(params, config->dvs_6axis_config);
	sh_css_set_dz_config(params, config->dz_config);
	sh_css_set_motion_vector(params, config->motion_vector);
	sh_css_set_shading_table(stream, config->shading_table);
	sh_css_set_morph_table(params, config->morph_table);
	sh_css_set_macc_table(params, config->macc_table);
	sh_css_set_gamma_table(params, config->gamma_table);
	sh_css_set_ctc_table(params, config->ctc_table);
	ia_css_set_dvs_coefficients(params, config->dvs_coefs);
	ia_css_set_dvs2_coefficients(params, config->dvs2_coefs);

	ia_css_set_configs(params, config);
	
	ia_css_set_param_exceptions(params);
	/*
	   if (config->_config)
	   ia_css_set_xnr_config(config->xnr_config);
	*/
#else /* defined(IS_ISP_2500_SYSTEM) */
	(void)params;
	sh_css_set_config_product_specific(config);
#endif
	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
		"sh_css_set_isp_config() leave: "
		"return_void\n");

	/* Now commit all changes to the SP */
	sh_css_param_update_isp_params(stream, sh_css_sp_is_running(), pipe);
	return IA_CSS_SUCCESS;
}

/* TODO: make a direct implementation and remove the partial ones */
void
ia_css_stream_get_isp_config(
	const struct ia_css_stream *stream,
	struct ia_css_isp_config *config)
{
	struct ia_css_isp_parameters *params = NULL;

	assert(config != NULL);

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_get_isp_config() enter: "
		"config=%p\n", config);

#if defined(IS_ISP_2500_SYSTEM)
	(void) stream;
	(void) params;

	sh_css_get_config_product_specific(config);

#else
	params = stream->isp_params_configs;
	assert(params != NULL);

	sh_css_get_ee_config(params, config->ee_config);
	sh_css_get_baa_config(params, config->baa_config);
	sh_css_get_dvs_6axis_config(params, config->dvs_6axis_config);
	sh_css_get_macc_table(params, config->macc_table);
	sh_css_get_gamma_table(params, config->gamma_table);
	sh_css_get_ctc_table(params, config->ctc_table);
	sh_css_get_dz_config(params, config->dz_config);
	sh_css_get_motion_vector(params, config->motion_vector);
	sh_css_get_anr_thres(params, config->anr_thres);

	ia_css_get_configs(params, config);
#endif

/*
	if (config->xnr_config != NULL)
		ia_css_get_xnr_config(config->xnr_config);
*/
	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
		"sh_css_get_isp_config() leave: "
		"return_void\n");
}

/*
 * coding style says the return of "mmgr_NULL" is the error signal
 *
 * Deprecated: Implement mmgr_realloc()
 */
static bool realloc_isp_css_mm_buf(
/* STORAGE_CLASS_INLINE bool realloc_isp_css_mm_buf( */
	hrt_vaddress *curr_buf, size_t *curr_size,
	size_t needed_size, bool force, enum ia_css_err *err,
	uint16_t	mmgr_attribute)
{
	int32_t id;
	*err = IA_CSS_SUCCESS;
	/* Possible optimization: add a function sh_css_isp_css_mm_realloc()
	 * and implement on top of hmm. */

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "realloc_isp_css_mm_buf() enter:\n");

	if (!force && *curr_size >= needed_size) {
	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "realloc_isp_css_mm_buf() leave:\n");
		return false;
	}
	/* don't reallocate if single ref to buffer and same size */
	if (*curr_size == needed_size && ia_css_refcount_is_single(*curr_buf)) {
	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "realloc_isp_css_mm_buf() leave:\n");
		return false;
	}

	id = IA_CSS_REFCOUNT_PARAM_BUFFER;
	ia_css_refcount_decrement(id, *curr_buf);
	*curr_buf = ia_css_refcount_increment(id, mmgr_alloc_attr(needed_size,
							mmgr_attribute));

	if (!*curr_buf) {
		*err = IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
		*curr_size = 0;
	} else {
		*curr_size = needed_size;
	}
	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "realloc_isp_css_mm_buf() leave:\n");
	return true;
}

static bool reallocate_buffer(
/* STORAGE_CLASS_INLINE bool reallocate_buffer( */
	hrt_vaddress *curr_buf,
	size_t *curr_size,
	size_t needed_size,
	bool force,
	enum ia_css_err *err)
{
	bool ret;
	uint16_t	mmgr_attribute = MMGR_ATTRIBUTE_DEFAULT;

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "reallocate_buffer() enter:\n");

	ret = realloc_isp_css_mm_buf(curr_buf,
		curr_size, needed_size, force, err, mmgr_attribute);

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "reallocate_buffer() leave:\n");
	return ret;
}

#if 0
static bool reallocate_cached_buffer(
/* STORAGE_CLASS_INLINE bool reallocate_cached_buffer( */
	hrt_vaddress *curr_buf,
	size_t *curr_size,
	size_t needed_size,
	enum ia_css_err *err)
{
	bool ret;
	uint16_t	mmgr_attribute = MMGR_ATTRIBUTE_DEFAULT |
		MMGR_ATTRIBUTE_CACHED;

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "reallocate_cached_buffer() enter:\n");

	ret = realloc_isp_css_mm_buf(curr_buf,
		curr_size, needed_size, false, err, mmgr_attribute);
		
	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "reallocate_cached_buffer() leave:\n");

	return ret;
}
#endif

struct ia_css_isp_3a_statistics *
ia_css_isp_3a_statistics_allocate(const struct ia_css_3a_grid_info *grid)
{
	struct ia_css_isp_3a_statistics *me;

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_isp_3a_statistics_allocate() enter: grid=%p\n",grid);

/* MW: Does "grid->enable" also control the histogram output ?? */
#if !defined(IS_ISP_2500_SYSTEM)
	assert(grid != NULL);
	if (!grid->enable)
		return NULL;
#endif

	me = sh_css_calloc(1,sizeof(*me));
	if (!me)
		goto err;

#if !defined(IS_ISP_2500_SYSTEM)

	if (grid->use_dmem) {
		int s3a_table_size = sizeof(struct ia_css_3a_output) *
					grid->aligned_width *
					grid->aligned_height;
		me->data.dmem.s3a_tbl = mmgr_malloc(s3a_table_size);
		if (me->data.dmem.s3a_tbl == mmgr_NULL)
			goto err;
	} else {
		int s3a_table_size = ISP_S3ATBL_HI_LO_STRIDE_BYTES *
					grid->aligned_height;
		me->data.vmem.s3a_tbl_hi = mmgr_malloc(s3a_table_size);
		if (me->data.vmem.s3a_tbl_hi == mmgr_NULL)
			goto err;
		me->data.vmem.s3a_tbl_lo = mmgr_malloc(s3a_table_size);
		if (me->data.vmem.s3a_tbl_lo == mmgr_NULL)
			goto err;
	}
	#if !defined(HAS_NO_HMEM)
		if ((me->data_hmem.rgby_tbl = mmgr_malloc(sizeof_hmem(HMEM0_ID))) == mmgr_NULL)
			goto err;
	#else
		me->data_hmem.rgby_tbl = mmgr_NULL;
	#endif

#else //For SKC we don't use any of  above modes but we can use same pointer + buf size is different
	me->data.dmem.s3a_tbl = mmgr_malloc(sizeof(struct stats_4a_private_raw_buffer));
	me->data_hmem.rgby_tbl = mmgr_NULL;
#endif



	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_isp_3a_statistics_allocate() leave: return=%p\n",me);

	return me;

err:
	ia_css_isp_3a_statistics_free(me);

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_isp_3a_statistics_allocate() leave: return=%p\n",NULL);

	return NULL;
}

void
ia_css_isp_3a_statistics_free(struct ia_css_isp_3a_statistics *me)
{
	if (me != NULL) {
/* mmgr_free() accepts (mmgr_)NULL, but the pointer are in a union, don't free twice */
		mmgr_free(me->data.dmem.s3a_tbl);
		me->data.dmem.s3a_tbl = mmgr_NULL;
		mmgr_free(me->data.vmem.s3a_tbl_hi);
		me->data.vmem.s3a_tbl_hi = mmgr_NULL;
		mmgr_free(me->data.vmem.s3a_tbl_lo);
		me->data.vmem.s3a_tbl_lo = mmgr_NULL;
#if !defined(HAS_NO_HMEM)
		mmgr_free(me->data_hmem.rgby_tbl);
		me->data_hmem.rgby_tbl = mmgr_NULL;
#endif
		sh_css_free(me);
	}
}

struct ia_css_isp_dvs_statistics *
ia_css_isp_dvs_statistics_allocate(const struct ia_css_dvs_grid_info *grid)
{
	struct ia_css_isp_dvs_statistics *me;
	int hor_size, ver_size;

	assert(grid != NULL);

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_isp_dvs_statistics_allocate() enter: grid=%p\n",grid);

	if (!grid->enable)
		return NULL;

	me = sh_css_calloc(1,sizeof(*me));
	if (!me)
		goto err;

	hor_size =
		sizeof(int) * IA_CSS_DVS_NUM_COEF_TYPES * grid->aligned_height;
	ver_size =
		sizeof(int) * IA_CSS_DVS_NUM_COEF_TYPES * grid->aligned_width;

	me->hor_size = hor_size;
	me->hor_proj = mmgr_malloc(hor_size);
	if (me->hor_proj == mmgr_NULL)
		goto err;
	me->ver_size = ver_size;
	me->ver_proj = mmgr_malloc(ver_size);
	if (me->ver_proj == mmgr_NULL)
		goto err;

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_isp_dvs_statistics_allocate() leave: return=%p\n",me);

	return me;
err:
	ia_css_isp_dvs_statistics_free(me);

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_isp_dvs_statistics_allocate() leave: return=%p\n",NULL);

	return NULL;
}

void
ia_css_isp_dvs_statistics_free(struct ia_css_isp_dvs_statistics *me)
{
	if (me != NULL) {
		mmgr_free(me->hor_proj);
		mmgr_free(me->ver_proj);
		sh_css_free(me);
	}
}


struct ia_css_isp_dvs_statistics *
ia_css_isp_dvs2_statistics_allocate(const struct ia_css_dvs_grid_info *grid)
{
	struct ia_css_isp_dvs_statistics *me;
	int hor_size, ver_size;

	assert(grid != NULL);

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_isp_dvs2_statistics_allocate() enter: grid=%p\n",grid);

	if (!grid->enable)
		return NULL;

	me = sh_css_calloc(1,sizeof(*me));
	if (!me)
		goto err;

	hor_size =
	ver_size = sizeof(int) * IA_CSS_DVS2_NUM_COEF_TYPES
		* grid->aligned_width * grid->aligned_height;

	me->hor_size = hor_size;
	me->hor_proj = mmgr_malloc(hor_size);
	if (me->hor_proj == mmgr_NULL)
		goto err;
	me->ver_size = ver_size;
	me->ver_proj = mmgr_malloc(ver_size);
	if (me->ver_proj == mmgr_NULL)
		goto err;

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_isp_dvs2_statistics_allocate() leave: return=%p\n",me);

	return me;
err:
	ia_css_isp_dvs2_statistics_free(me);

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_isp_dvs2_statistics_allocate() leave: return=%p\n",NULL);

	return NULL;
}

void
ia_css_isp_dvs2_statistics_free(struct ia_css_isp_dvs_statistics *me)
{
	if (me != NULL) {
		mmgr_free(me->hor_proj);
		mmgr_free(me->ver_proj);
		sh_css_free(me);
	}
}

struct ia_css_metadata *
ia_css_metadata_allocate(unsigned int size)
{
	struct ia_css_metadata *md = NULL;

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
		"ia_css_metadata_allocate() enter: size=%p\n", size);

	if (size == 0)
		return NULL;

	if (size > SH_CSS_MAX_METADATA_BUFFER_SIZE)
		return NULL;

	md = sh_css_malloc(sizeof(*md));
	if (md == NULL)
		goto error;

	/* Make metadata buffer size multiple of DDR bus width for DMA. */
	md->size = CEIL_MUL(size, HIVE_ISP_DDR_WORD_BYTES);
	md->address = mmgr_malloc(md->size);
	if (md->address == mmgr_NULL)
		goto error;

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
		"ia_css_metadata_allocate() leave: return=%p\n", md);
	return md;

error:
	ia_css_metadata_free(md);
	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
		"ia_css_metadata_allocate() leave: return=%p\n", NULL);
	return NULL;
}

void
ia_css_metadata_free(struct ia_css_metadata *me)
{
	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
		"ia_css_metadata_free() enter: me=%p\n", me);

	if (me != NULL) {
		mmgr_free(me->address);
		sh_css_free(me);
	}

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
		"ia_css_metadata_free() leave: return_void\n");
}

unsigned g_param_buffer_dequeue_count = 0;
unsigned g_param_buffer_enqueue_count = 0;

enum ia_css_err
ia_css_stream_isp_parameters_init(struct ia_css_stream *stream)
{
	enum ia_css_err err = IA_CSS_SUCCESS;
	bool succ = true;
	unsigned isp_pipe_version = 1;
	unsigned i;
	struct sh_css_ddr_address_map *ddr_ptrs;
	struct sh_css_ddr_address_map_size *ddr_ptrs_size;
	struct ia_css_isp_parameters *params;
	size_t params_size;

	assert(stream != NULL);

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
			    "ia_css_stream_isp_parameters_init() enter: void\n");

	/* TMP: tracking of paramsets */
	g_param_buffer_dequeue_count = 0;
	g_param_buffer_enqueue_count = 0;

	isp_pipe_version = ia_css_pipe_get_isp_pipe_version(stream->pipes[0]);
	// this code assuemes that all the pipes have the same pipeversion.
	for (i = 1; i < (unsigned)stream->num_pipes; i++) {
	    assert(isp_pipe_version == ia_css_pipe_get_isp_pipe_version(stream->pipes[i]));
	}

	stream->isp_params_configs = sh_css_malloc(sizeof(*stream->isp_params_configs));
	if (!stream->isp_params_configs)
	{
		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
			"ia_css_stream_isp_parameters_init() leave: "
			"return_err=%d\n",IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY);
		return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
	} else {
		memset(stream->isp_params_configs, 0, sizeof(*stream->isp_params_configs));
	}

	params = stream->isp_params_configs;
	ddr_ptrs = &params->ddr_ptrs;
	ddr_ptrs_size = &params->ddr_ptrs_size;

	for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++) {
		memset(&params->pipe_ddr_ptrs[i], 0,
			sizeof(params->pipe_ddr_ptrs[i]));
		memset(&params->pipe_ddr_ptrs_size[i], 0,
			sizeof(params->pipe_ddr_ptrs_size[i]));
	}

	memset(ddr_ptrs, 0, sizeof(*ddr_ptrs));
	memset(ddr_ptrs_size, 0, sizeof(*ddr_ptrs_size));

#if !defined(IS_ISP_2500_SYSTEM)
	params_size = sizeof(params->uds);
#else
	params_size = sizeof(struct sh_css_isp_params);
#endif
	ddr_ptrs_size->isp_param = params_size;
	ddr_ptrs->isp_param = ia_css_refcount_increment(IA_CSS_REFCOUNT_PARAM_BUFFER,
				mmgr_malloc(params_size));
	succ &= (ddr_ptrs->isp_param != mmgr_NULL);

#if defined(IS_ISP_2500_SYSTEM)
	ddr_ptrs_size->acc_cluster_data_for_sp = sizeof(sh_css_acc_cluster_parameters_t);
	ddr_ptrs->acc_cluster_data_for_sp = ia_css_refcount_increment(IA_CSS_REFCOUNT_PARAM_BUFFER,
				mmgr_malloc(sizeof(sh_css_acc_cluster_parameters_t)));
	succ &= (ddr_ptrs->acc_cluster_data_for_sp != mmgr_NULL);
#endif

#if !defined(IS_ISP_2500_SYSTEM)
	ddr_ptrs_size->macc_tbl = sizeof(struct ia_css_macc_table);
	ddr_ptrs->macc_tbl = ia_css_refcount_increment(IA_CSS_REFCOUNT_PARAM_BUFFER,
				mmgr_malloc(sizeof(struct ia_css_macc_table)));
	succ &= (ddr_ptrs->macc_tbl != mmgr_NULL);

	ddr_ptrs_size->anr_thres = sizeof(struct ia_css_anr_thres);
	ddr_ptrs->anr_thres = ia_css_refcount_increment(IA_CSS_REFCOUNT_PARAM_BUFFER,
			mmgr_malloc(sizeof(struct ia_css_anr_thres)));
	succ &= (ddr_ptrs->anr_thres != mmgr_NULL);
#endif

#if !defined(IS_ISP_2500_SYSTEM)
	
	sh_css_set_nr_config(params, &default_nr_config);
	sh_css_set_ee_config(params, &default_ee_config);
	if (isp_pipe_version == 1)
		sh_css_set_macc_table(params, &default_macc_table);
	else
		sh_css_set_macc_table(params, &default_macc2_table);
	sh_css_set_gamma_table(params, &default_gamma_table);
	sh_css_set_ctc_table(params, &default_ctc_table);
	sh_css_set_anr_thres(params, &default_anr_thres);
	sh_css_set_baa_config(params, &default_baa_config);
	sh_css_set_dz_config(params, &default_dz_config);

	ia_css_set_s3a_config(params, &default_3a_config);
	ia_css_set_wb_config(params, &default_wb_config);
	ia_css_set_csc_config(params, &default_cc_config);
	ia_css_set_tnr_config(params, &default_tnr_config);
	ia_css_set_ob_config(params, &default_ob_config);
	ia_css_set_dp_config(params, &default_dp_config);
	ia_css_set_de_config(params, &default_de_config);
	ia_css_set_gc_config(params, &default_gc_config);
	ia_css_set_anr_config(params, &default_anr_config);
	ia_css_set_ce_config(params, &default_ce_config);
	ia_css_set_xnr_table_config(params, &default_xnr_table);
	ia_css_set_ecd_config(params, &default_ecd_config);
	ia_css_set_ynr_config(params, &default_ynr_config);
	ia_css_set_fc_config(params, &default_fc_config);
	ia_css_set_cnr_config(params, &default_cnr_config);
	ia_css_set_macc_config(params, &default_macc_config);
	ia_css_set_ctc_config(params, &default_ctc_config);
	ia_css_set_aa_config(params, &default_aa_config);
	ia_css_set_r_gamma_config(params, &default_r_gamma_table);
	ia_css_set_g_gamma_config(params, &default_g_gamma_table);
	ia_css_set_b_gamma_config(params, &default_b_gamma_table);
	ia_css_set_yuv2rgb_config(params, &default_yuv2rgb_cc_config);
	ia_css_set_rgb2yuv_config(params, &default_rgb2yuv_cc_config);
	ia_css_set_xnr_config(params, &default_xnr_config);

	ia_css_set_param_exceptions(params);

	for (i = 0; i < N_GDC_ID; i++)
		gdc_lut_store((gdc_ID_t)i, zoom_table);
	params->fpn_config.data = NULL;
	params->config_changed[IA_CSS_FPN_ID] = true;
	params->fpn_config.enabled = 0;
	params->morph_table = NULL;
	params->morph_table_changed = true;
	params->sc_table = NULL;
	params->sc_table_changed = true;
	params->motion_config = default_motion_config;
	params->motion_config_changed = true;
	params->dvs2_hor_coefs.odd_real = NULL;
	params->dvs2_hor_coefs.odd_imag = NULL;
	params->dvs2_hor_coefs.even_real = NULL;
	params->dvs2_hor_coefs.even_imag = NULL;
	params->dvs2_ver_coefs.odd_real = NULL;
	params->dvs2_ver_coefs.odd_imag = NULL;
	params->dvs2_ver_coefs.even_real = NULL;
	params->dvs2_ver_coefs.even_imag = NULL;
	params->dvs2_coef_table_changed = true;

	params->dis_hor_coef_tbl = NULL;
	params->dis_ver_coef_tbl = NULL;
	params->dis_coef_table_changed = true;

	/*Initialise and generate table later in star*/
	params->dvs_6axis_config = NULL;
	params->dvs_6axis_config_changed = true;
#endif

#if defined(IS_ISP_2500_SYSTEM)
	sh_css_set_default_product_specific();
#endif

	if (!succ)
		return IA_CSS_ERR_INTERNAL_ERROR;

	/* now commit to ddr */
	err = sh_css_param_update_isp_params(stream, false, NULL);
	if (err != IA_CSS_SUCCESS)
		return err;
 
	/* create per pipe reference to general ddr_ptrs */
	for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++) {
		ref_sh_css_ddr_address_map(ddr_ptrs, &params->pipe_ddr_ptrs[i]);
		params->pipe_ddr_ptrs_size[i] = *ddr_ptrs_size;
	}

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
		"ia_css_stream_isp_parameters_init() leave: "
		"return_err=%d\n",IA_CSS_SUCCESS);

	return IA_CSS_SUCCESS;
}

enum ia_css_err
sh_css_params_init(void)
{
	int i, p;

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_params_init() enter: void\n");
	
	/* TMP: tracking of paramsets */
	g_param_buffer_dequeue_count = 0;
	g_param_buffer_enqueue_count = 0;

	for (p = 0; p < IA_CSS_PIPE_ID_NUM; p++) {
		for (i = 0; i < SH_CSS_MAX_STAGES; i++) {
			xmem_sp_stage_ptrs[p][i] =
					ia_css_refcount_increment(-1,
					    mmgr_calloc(1,
					    sizeof(struct sh_css_sp_stage)));
			xmem_isp_stage_ptrs[p][i] =
					ia_css_refcount_increment(-1,
					    mmgr_calloc(1,
					    sizeof(struct sh_css_isp_stage)));

			if ((xmem_sp_stage_ptrs[p][i] == mmgr_NULL) ||
				(xmem_isp_stage_ptrs[p][i] == mmgr_NULL))
			{
				sh_css_params_uninit();
				ia_css_debug_dtrace(IA_CSS_DEBUG_ERROR,
					"sh_css_params_init() leave: "
					"return_err=%d\n",IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY);
				return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
			}
		}
	}

#if !defined(IS_ISP_2500_SYSTEM)
	ia_css_config_gamma_table();
	ia_css_config_ctc_table();
	ia_css_config_rgb_gamma_tables();
	ia_css_config_xnr_table();
#endif

	sp_ddr_ptrs = ia_css_refcount_increment(-1, mmgr_calloc(1,
		CEIL_MUL(sizeof(struct sh_css_ddr_address_map),
			 HIVE_ISP_DDR_WORD_BYTES)));
	xmem_sp_group_ptrs = ia_css_refcount_increment(-1, mmgr_calloc(1,
		sizeof(struct sh_css_sp_group)));

	if ((sp_ddr_ptrs == mmgr_NULL) ||
	    (xmem_sp_group_ptrs == mmgr_NULL)) {
		ia_css_uninit();
		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
			"sh_css_params_init() leave: "
			"return_err=%d\n",IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY);
			return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
	}
	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
		"sh_css_params_init() leave: "
		"return_err=%d\n",IA_CSS_SUCCESS);
	return IA_CSS_SUCCESS;
}

#if !defined(IS_ISP_2500_SYSTEM)
void sh_css_params_reconfigure_gdc_lut(void)
{
	unsigned i;

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_params_reconfigure_gdc_lut() enter: void\n");

	for (i = 0; i < N_GDC_ID; i++)
		gdc_lut_store((gdc_ID_t)i, zoom_table);

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_params_reconfigure_gdc_lut() leave: return_void\n");
}
#endif

static void free_map_callback(
	hrt_vaddress ptr)
{
	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "free_map_callback() enter:\n");

	free_sh_css_ddr_address_map(ptr);

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "free_map_callback() leave:\n");
}

static void free_buffer_callback(
	hrt_vaddress ptr)
{
	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "free_buffer_callback() enter:\n");

	mmgr_free(ptr);

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "free_buffer_callback() leave:\n");
}

void
sh_css_param_clear_param_sets(void)
{
	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_param_clear_param_sets() enter:\n");

	ia_css_refcount_clear(IA_CSS_REFCOUNT_PARAM_SET_POOL, &free_map_callback);

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_param_clear_param_sets() leave:\n");
}

/*
 * MW: we can define mmgr_free() to return a NULL
 * then you can write ptr = mmgr_free(ptr);
 */
#define safe_free(id, x)      \
	do {                  \
		ia_css_refcount_decrement(id, x);     \
		(x) = mmgr_NULL;  \
	} while (0)

static void free_map(struct sh_css_ddr_address_map *map)
{
	unsigned int i;

	hrt_vaddress *addrs = (hrt_vaddress *)map;

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "free_map() enter:\n");

	/* free buffers */
	for (i = 0; i < (sizeof(struct sh_css_ddr_address_map_size)/
						sizeof(size_t)); i++) {
		if (addrs[i] == mmgr_NULL)
			continue;
		safe_free(IA_CSS_REFCOUNT_PARAM_BUFFER, addrs[i]);
	}

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "free_map() leave:\n");
}

void
ia_css_stream_isp_parameters_uninit(struct ia_css_stream *stream)
{
	int i;
	struct ia_css_isp_parameters *params = stream->isp_params_configs;

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_stream_isp_parameters_uninit() enter\n");
	/* free existing ddr_ptr maps */
	for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++)
		free_map(&params->pipe_ddr_ptrs[i]);
	free_map(&params->ddr_ptrs);

#if !defined(IS_ISP_2500_SYSTEM)
	if (params->fpn_config.data)
		sh_css_free(params->fpn_config.data);
#endif

	/*Free up theDVS table memory blocks before recomputing new table  */
	if(params->dvs_6axis_config)
		free_dvs_6axis_table(&(params->dvs_6axis_config));

	sh_css_free(params);
	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_stream_isp_parameters_uninit() leave\n");
}

void
sh_css_params_uninit(void)
{
	unsigned p, i;

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_params_uninit() enter:\n");

	ia_css_refcount_decrement(-1, sp_ddr_ptrs);
	sp_ddr_ptrs = mmgr_NULL;
	ia_css_refcount_decrement(-1, xmem_sp_group_ptrs);
	xmem_sp_group_ptrs = mmgr_NULL;

	for (p = 0; p < IA_CSS_PIPE_ID_NUM; p++)
		for (i = 0; i < SH_CSS_MAX_STAGES; i++) {
			ia_css_refcount_decrement(-1, xmem_sp_stage_ptrs[p][i]);
			xmem_sp_stage_ptrs[p][i] = mmgr_NULL;
			ia_css_refcount_decrement(-1, xmem_isp_stage_ptrs[p][i]);
			xmem_isp_stage_ptrs[p][i] = mmgr_NULL;
		}

	/* go through the pools to clear references */
	ia_css_refcount_clear(IA_CSS_REFCOUNT_PARAM_SET_POOL, &free_map_callback);
	ia_css_refcount_clear(IA_CSS_REFCOUNT_PARAM_BUFFER, &free_buffer_callback);
	ia_css_refcount_clear(-1, &free_buffer_callback);

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_params_uninit() leave: return_void\n");
}

#if !defined(IS_ISP_2500_SYSTEM)
static void write_morph_plane(
	unsigned short *data,
	unsigned int width,
	unsigned int height,
	hrt_vaddress dest,
	unsigned int aligned_width)
{
	unsigned int i, padding, w;

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "write_morph_plane() enter:\n");

	/* currently we don't have morph table interpolation yet,
	 * so we allow a wider table to be used. This will be removed
	 * in the future. */
	if (width > aligned_width) {
		padding = 0;
		w = aligned_width;
	} else {
		padding = aligned_width - width;
		w = width;
	}

	for (i = 0; i < height; i++) {
		mmgr_store(dest, data, w * sizeof(short));
		dest += w * sizeof(short);
		mmgr_clear(dest, padding * sizeof(short));
		dest += padding * sizeof(short);
		data += width;
	}

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "write_morph_plane() leave:\n");
}
#endif

#if !defined(IS_ISP_2500_SYSTEM)
/* Store the DIS coefficients from the 3A library to DDR where the ISP
   will read them from. The ISP works on a grid that can be larger than
   that of the 3a library. If that is the case, we padd the difference
   with zeroes. */
static void store_dis_coefficients(
	struct ia_css_isp_parameters *params,
	const struct ia_css_binary *binary,
	hrt_vaddress ddr_addr_hor,
	hrt_vaddress ddr_addr_ver)
{
	unsigned int hor_num_isp, ver_num_isp,
		     hor_num_3a, ver_num_3a,
		     hor_padding, ver_padding;
	int i;
	const short *hor_ptr_3a,
		*ver_ptr_3a;
	hrt_vaddress hor_ptr_isp = ddr_addr_hor,
		ver_ptr_isp = ddr_addr_ver;

	assert(params != NULL);
	assert(binary != NULL);
	assert(ddr_addr_hor != mmgr_NULL);
	assert(ddr_addr_ver != mmgr_NULL);

	hor_num_isp = binary->dis_hor_coef_num_isp,
	ver_num_isp = binary->dis_ver_coef_num_isp,
	hor_num_3a  = binary->dis_hor_coef_num_3a,
	ver_num_3a  = binary->dis_ver_coef_num_3a,
	hor_padding = hor_num_isp - hor_num_3a,
	ver_padding = ver_num_isp - ver_num_3a;
	hor_ptr_3a = params->dis_hor_coef_tbl,
	ver_ptr_3a = params->dis_ver_coef_tbl;

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "store_dis_coefficients() enter:\n");

	for (i = 0; i < IA_CSS_DVS_NUM_COEF_TYPES; i++) {
		if (params->dis_hor_coef_tbl != NULL) {
			mmgr_store(hor_ptr_isp,
				hor_ptr_3a, hor_num_3a * sizeof(*hor_ptr_3a));
			hor_ptr_3a  += hor_num_3a;
		} else {
			mmgr_clear(hor_ptr_isp,
				hor_num_3a * sizeof(*hor_ptr_3a));
		}
		hor_ptr_isp += hor_num_3a * sizeof(short);
		mmgr_clear(hor_ptr_isp, hor_padding * sizeof(short));
		hor_ptr_isp += hor_padding * sizeof(short);
	}
	for (i = 0; i < SH_CSS_DIS_VER_NUM_COEF_TYPES(binary); i++) {
		if (params->dis_ver_coef_tbl != NULL) {
			mmgr_store(ver_ptr_isp,
				ver_ptr_3a, ver_num_3a * sizeof(*ver_ptr_3a));
			ver_ptr_3a  += ver_num_3a;
		} else {
			mmgr_clear(ver_ptr_isp,
				ver_num_3a * sizeof(*ver_ptr_3a));
		}
		ver_ptr_isp += ver_num_3a * sizeof(short);
		mmgr_clear(ver_ptr_isp, ver_padding * sizeof(short));
		ver_ptr_isp += ver_padding * sizeof(short);
	}

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "store_dis_coefficients() leave:\n");
}
#endif

#if !defined(IS_ISP_2500_SYSTEM)
static void storedvs2_coef(const short *ptr_3a, hrt_vaddress ptr_isp, unsigned num_3a, unsigned padding)
{
	if (ptr_3a != NULL) {
		mmgr_store(ptr_isp, ptr_3a, num_3a * sizeof(*ptr_3a));
	} else {
		mmgr_clear(ptr_isp, num_3a * sizeof(*ptr_3a));
	}
	ptr_isp += num_3a * sizeof(short);
	mmgr_clear(ptr_isp, padding * sizeof(short));

}
#endif

#if !defined(IS_ISP_2500_SYSTEM)
static void store_dvs2_coefficients(
	struct ia_css_isp_parameters *params,
	const struct ia_css_binary *binary,
	hrt_vaddress ddr_addr_hor,
	hrt_vaddress ddr_addr_ver)
{
	unsigned int hor_num_isp, ver_num_isp,
		     hor_num_3a, ver_num_3a,
		     hor_padding, ver_padding;
	hrt_vaddress hor_ptr_isp = ddr_addr_hor,
		ver_ptr_isp = ddr_addr_ver;

	assert(binary != NULL);
	assert(ddr_addr_hor != mmgr_NULL);
	assert(ddr_addr_ver != mmgr_NULL);

	hor_num_isp = binary->dis_hor_coef_num_isp,
	ver_num_isp = binary->dis_ver_coef_num_isp,
	hor_num_3a  = binary->dis_hor_coef_num_3a,
	ver_num_3a  = binary->dis_ver_coef_num_3a,
	hor_padding = hor_num_isp - hor_num_3a,
	ver_padding = ver_num_isp - ver_num_3a;

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "store_dvs2_coefficients() enter:\n");

	storedvs2_coef(params->dvs2_hor_coefs.odd_real, hor_ptr_isp, hor_num_3a, hor_padding);
	hor_ptr_isp += hor_num_isp * sizeof(short);
	storedvs2_coef(params->dvs2_hor_coefs.odd_imag, hor_ptr_isp, hor_num_3a, hor_padding);
	hor_ptr_isp += hor_num_isp * sizeof(short);
	storedvs2_coef(params->dvs2_hor_coefs.even_real, hor_ptr_isp, hor_num_3a, hor_padding);
	hor_ptr_isp += hor_num_isp * sizeof(short);
	storedvs2_coef(params->dvs2_hor_coefs.even_imag, hor_ptr_isp, hor_num_3a, hor_padding);

	storedvs2_coef(params->dvs2_ver_coefs.odd_real, ver_ptr_isp, ver_num_3a, ver_padding);
	ver_ptr_isp += ver_num_isp * sizeof(short);
	storedvs2_coef(params->dvs2_ver_coefs.odd_imag, ver_ptr_isp, ver_num_3a, ver_padding);
	ver_ptr_isp += ver_num_isp * sizeof(short);
	storedvs2_coef(params->dvs2_ver_coefs.even_real, ver_ptr_isp, ver_num_3a, ver_padding);
	ver_ptr_isp += ver_num_isp * sizeof(short);
	storedvs2_coef(params->dvs2_ver_coefs.even_imag, ver_ptr_isp, ver_num_3a, ver_padding);

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "store_dvs2_coefficients() leave:\n");
}
#endif

static void sh_css_update_isp_params_to_ddr(
	struct ia_css_isp_parameters *params,
	hrt_vaddress ddr_ptr)
{
#if !defined(IS_ISP_2500_SYSTEM)
	size_t size = sizeof(params->uds);
#else
	size_t size = sizeof(struct sh_css_isp_params);
#endif

	assert(params != NULL);

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
			    "sh_css_update_isp_params_to_ddr() enter:\n");

#ifdef HRT_CSIM
	{
		/* ispparm struct is read with DMA which reads
		 * multiples of the DDR word with (32 bytes):
		 * So we pad with zeroes to prevent warnings in csim.
		 */
		unsigned int aligned_width, padding_bytes;
		hrt_vaddress pad_ptr;

		aligned_width = CEIL_MUL(
				  size,
				  HIVE_ISP_DDR_WORD_BYTES);
		padding_bytes = aligned_width - size;
		pad_ptr = ddr_ptr +size;
		mmgr_clear(pad_ptr, padding_bytes);
	}
#endif
#if !defined(IS_ISP_2500_SYSTEM)
	mmgr_store(ddr_ptr, &(params->uds), size);
#else
	mmgr_store(ddr_ptr, &(params->isp_parameters), size);
#endif

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_update_isp_params_to_ddr() leave:\n");
}

#if !defined(IS_ISP_2500_SYSTEM)
static void sh_css_update_isp_mem_params_to_ddr(
	const struct ia_css_binary *binary,
	hrt_vaddress ddr_mem_ptr,
	size_t size,
	enum ia_css_isp_memories mem)
{
	const struct ia_css_host_data *params;

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_update_isp_mem_params_to_ddr() enter:\n");

	params = ia_css_isp_param_get_mem_init(&binary->mem_params, IA_CSS_PARAM_CLASS_PARAM, mem);
	mmgr_store(ddr_mem_ptr, params->address, size);

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_update_isp_memparams_to_ddr() leave:\n");
}
#endif

#if defined(IS_ISP_2500_SYSTEM)
void
sh_css_update_acc_cluster_data_to_ddr(hrt_vaddress ddr_ptr)
{
#ifdef HRT_CSIM
	/* ispparm struct is read with DMA which reads
	 * multiples of the DDR word with (32 bytes):
	 * So we pad with zeroes to prevent warnings in csim.
	 */
	unsigned int aligned_width, padding_bytes;
	hrt_vaddress pad_ptr;

	aligned_width = CEIL_MUL(sizeof(sh_css_acc_cluster_parameters_t),
				 HIVE_ISP_DDR_WORD_BYTES);
	padding_bytes = aligned_width - sizeof(sh_css_acc_cluster_parameters_t);
	pad_ptr = ddr_ptr + sizeof(sh_css_acc_cluster_parameters_t);
	mmgr_clear(pad_ptr, padding_bytes);
#endif
	mmgr_store(ddr_ptr,
	     &acc_cluster_parameters,
	     sizeof(sh_css_acc_cluster_parameters_t));
}
#endif

void ia_css_dequeue_param_buffers(void)
{
	hrt_vaddress cpy;
	ia_css_queue_t *q;

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_dequeue_param_buffers() enter\n");
	/* Get queue instance */
	q = sh_css_get_queue(sh_css_sp2host_buffer_queue,
			     sh_css_param_buffer_queue, -1);
	if ( NULL == q ) {
		/* Error as the queue is not initialized */
		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
			"ia_css_dequeue_param_buffers() leave: err%d\n",
			IA_CSS_ERR_RESOURCE_NOT_AVAILABLE);
		return;
	}

	/* clean-up old copy */
	while (IA_CSS_SUCCESS == ia_css_queue_dequeue(q, (uint32_t *)&cpy)) {
		/* TMP: keep track of dequeued param set count
		 */
		ia_css_queue_t *eventq;
		g_param_buffer_dequeue_count++;
		eventq = sh_css_get_queue(sh_css_host2sp_event_queue,
					-1, -1);

		/*no need to check validity of eventq as queue is
		 * initialized by the time we reach here.*/
		/*
		 * Tell the SP which queues are not full,
		 * by sending the software event.
		 */
		ia_css_eventq_send(eventq,
				SP_SW_EVENT_ID_2,
				0,
				sh_css_param_buffer_queue,
				0);

		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
			"ia_css_dequeue_param_buffers: "
			"dequeued param set %x from %d\n",
			cpy, 0);
			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
				"ia_css_dequeue_param_buffers: "
				"release ref on param set %x\n",
				cpy);
			free_sh_css_ddr_address_map(cpy);
	}

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_dequeue_param_buffers() leave\n");
}

#if !defined(IS_ISP_2500_SYSTEM)
static void
process_kernel_parameters(unsigned int pipe_id,
			  struct ia_css_pipeline_stage *stage,
			  struct ia_css_isp_parameters *params,
			  unsigned int isp_pipe_version,
			  unsigned int raw_bit_depth)
{
	unsigned param_id;

	sh_css_enable_pipeline(stage->binary);

	if (params->config_changed[IA_CSS_OB_ID]) {
		ia_css_ob_configure(&params->stream_configs.ob,
			    isp_pipe_version, raw_bit_depth);
	}
	if (params->config_changed[IA_CSS_S3A_ID]) {
		ia_css_s3a_configure(raw_bit_depth);
	}

	/* Call parameter process functions for all kernels */
	/* Skip SC, since that is called on a temp sc table */
	for (param_id = 0; param_id < IA_CSS_NUM_PARAMETER_IDS; param_id++) {
		if (param_id == IA_CSS_SC_ID) continue;
		if (params->config_changed[param_id])
			ia_css_kernel_process_param[param_id](pipe_id, stage, params);
	}
}
#endif

enum ia_css_err
sh_css_param_update_isp_params(struct ia_css_stream *stream, bool commit, struct ia_css_pipe *pipe_in)
{
	enum ia_css_err err = IA_CSS_SUCCESS;
	hrt_vaddress cpy;
	int i;
	unsigned int raw_bit_depth = 10;
	unsigned int isp_pipe_version = 1;
	struct ia_css_isp_parameters *params;
	bool acc_cluster_params_changed = false;

	(void)acc_cluster_params_changed;

	assert(stream != NULL);

	params = stream->isp_params_configs;

	raw_bit_depth = ia_css_stream_input_format_bits_per_pixel(stream);
	isp_pipe_version = ia_css_pipe_get_isp_pipe_version(stream->pipes[0]);
	// this code assuemes that all the pipes have the same pipeversion.
	for(i=1; i< stream->num_pipes; i++) {
		assert(isp_pipe_version == ia_css_pipe_get_isp_pipe_version(stream->pipes[i]));
	}


	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_param_update_isp_params() enter:\n");

#if !defined(IS_ISP_2500_SYSTEM)
#else /* defined(IS_ISP_2500_SYSTEM) */
	sh_css_process_product_specific(&params->isp_parameters,&params->isp_params_changed);
	sh_css_process_acc_cluster_parameters(stream, &acc_cluster_parameters, &acc_cluster_params_changed );
#endif

	/* now make the map available to the sp */
	if (!commit) {
		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
			"sh_css_param_update_isp_params() leave:\n");
		return err;
	}
	/* enqueue a copies of the mem_map to
	   the designated pipelines */
	for (i = 0; i < stream->num_pipes; i++) {
		struct ia_css_pipe *pipe;
		struct sh_css_ddr_address_map *cur_map;
		struct sh_css_ddr_address_map_size *cur_map_size;
		struct sh_css_ddr_address_map tmp_map;
		struct sh_css_ddr_address_map_size tmp_map_size;
		struct ia_css_pipeline *pipeline;
		struct ia_css_pipeline_stage *stage;
		unsigned int thread_id, pipe_num;
		ia_css_queue_t *q;

		(void)stage;
		pipe = stream->pipes[i];
		pipeline = ia_css_pipe_get_pipeline(pipe);
		pipe_num = ia_css_pipe_get_pipe_num(pipe);
		ia_css_pipeline_get_sp_thread_id(pipe_num, &thread_id);

		q = sh_css_get_queue(sh_css_host2sp_buffer_queue,
			     sh_css_param_buffer_queue, thread_id);
		if ( NULL == q ) {
			/* Error as the queue is not initialized */
			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
				"sh_css_param_update_isp_params: "
				"error=%d\n",
				IA_CSS_ERR_RESOURCE_NOT_AVAILABLE);
			err = IA_CSS_ERR_RESOURCE_NOT_AVAILABLE;
			break;
		}


		cur_map = &params->pipe_ddr_ptrs[pipeline->pipe_id];
		cur_map_size = &params->pipe_ddr_ptrs_size[pipeline->pipe_id];

#if !defined(IS_ISP_2500_SYSTEM)
		/* TODO: Normally, zoom and motion parameters shouldn't
		 * be part of "isp_params" as it is resolution/pipe dependant
		 * Therefore, move the zoom config elsewhere (e.g. shading
		 * table can be taken as an example! @GC
		 * */
#if 0
		if (params->isp_params_changed || params->dz_config_changed ||
				params->motion_config_changed) {
#else
		/* This should be unconditional, since the sh_css_params_write_to_ddr_internal below
		 * is also unconditional. Otherwise, the old uds parameters, e.g. for
		 * another pipeline, can be taken.
		*/
		{
#endif
			/* we have to do this per pipeline because */
			/* the processing is a.o. resolution dependent */
			ia_css_process_zoom_and_motion(params,
							pipeline->pipe_id,
							pipeline->stages);
			params->isp_params_changed = true;
		}
#endif

		/* BZ 125915, should be moved till after "update other buff" */
		/* update the other buffers to the pipe specific copies */
		for (stage = pipeline->stages; stage; stage = stage->next) {
			unsigned mem;
			
			if (!stage || !stage->binary) continue;
#if !defined(IS_ISP_2500_SYSTEM)
			process_kernel_parameters(pipeline->pipe_id,
				stage, params,
				isp_pipe_version, raw_bit_depth);
#endif
			err =
			  sh_css_params_write_to_ddr_internal(
						pipeline->pipe_id,
						params,
						stage,
						cur_map,
						cur_map_size);
			if (err != IA_CSS_SUCCESS)
				break;
			for (mem = 0; mem < IA_CSS_NUM_ISP_MEMORIES; mem++) {
				params->isp_mem_params_changed
					[pipeline->pipe_id][stage->stage_num][mem] = false;
			}
		}
		/* update isp_params to pipe specific copies */
		if (params->isp_params_changed) {
			reallocate_buffer(&cur_map->isp_param,
				  &cur_map_size->isp_param,
				  cur_map_size->isp_param,
				  true,
				  &err);
			if (err != IA_CSS_SUCCESS)
				break;
			sh_css_update_isp_params_to_ddr(params, cur_map->isp_param);
		}
#if defined(IS_ISP_2500_SYSTEM)
		if (acc_cluster_params_changed || params->isp_params_changed)
		{
			reallocate_buffer(&cur_map->acc_cluster_data_for_sp ,
				  &cur_map_size->acc_cluster_data_for_sp ,
				  cur_map_size->acc_cluster_data_for_sp ,
				  true,
				  &err);
			sh_css_update_acc_cluster_data_to_ddr( cur_map->acc_cluster_data_for_sp );
		}
#endif

		/* check if to actually update the parameters for this pipe */
		if (pipe_in && (pipe != pipe_in)) {
			ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
				"sh_css_param_update_isp_params: "
				"skipping pipe %x\n",
				pipe);
			continue;
		}
		/* last make referenced copy */
		err = ref_sh_css_ddr_address_map(
					cur_map,
					&tmp_map);
		if (err != IA_CSS_SUCCESS)
			break;
		tmp_map_size = *cur_map_size;
		/* now write the copy to ddr */
		err = write_sh_css_address_map_to_ddr(&tmp_map, &cpy);
		if (err != IA_CSS_SUCCESS)
			break;

		/* enqueue the set to sp */
		ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
			"sh_css_param_update_isp_params: "
			"queue param set %x to %d\n",
			cpy, thread_id);

		if (IA_CSS_SUCCESS !=
		    ia_css_queue_enqueue(q, (uint32_t)cpy)) {
			free_sh_css_ddr_address_map(cpy);
		}
		else {
			/* TMP: check discrepancy between nr of enqueued
			 * parameter sets and dequeued sets
			 */
			ia_css_queue_t *eventq;
			g_param_buffer_enqueue_count++;
			assert(g_param_buffer_enqueue_count < g_param_buffer_dequeue_count+50);
			/*
			 * Tell the SP which queues are not empty,
			 * by sending the software event.
			 */
			eventq = sh_css_get_queue(sh_css_host2sp_event_queue,
					-1, -1);
			if (NULL == eventq) {
				/* Error as the queue is not initialized */
				ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE,
					"sh_css_param_update_isp_params() leaving:"
					"eventq unavailable\n");
				return IA_CSS_ERR_RESOURCE_NOT_AVAILABLE;
			}
			ia_css_eventq_send(eventq,
					SP_SW_EVENT_ID_1,
					(uint8_t)thread_id,
					(uint8_t)sh_css_param_buffer_queue,
					0);
		}
		/* clean-up old copy */
		ia_css_dequeue_param_buffers();
	} /* end for each 'active' pipeline */
	/* clear the changed flags after all params
	   for all pipelines have been updated */
	params->isp_params_changed = false;
	params->sc_table_changed = false;
	params->anr_thres_changed = false;
	params->dis_coef_table_changed = false;
	params->dvs2_coef_table_changed = false;
	params->morph_table_changed = false;
	params->dz_config_changed = false;
	params->motion_config_changed = false;
	params->dvs_6axis_config_changed = false;

	memset(&params->config_changed[0], 0, sizeof(params->config_changed));

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_param_update_isp_params() leave:\n");
	return err;
}

static enum ia_css_err
sh_css_params_write_to_ddr_internal(
	unsigned pipe_id,
	struct ia_css_isp_parameters *params,
	const struct ia_css_pipeline_stage *stage,
	struct sh_css_ddr_address_map *ddr_map,
	struct sh_css_ddr_address_map_size *ddr_map_size)
{
	enum ia_css_err err;
	const struct ia_css_binary *binary;

	unsigned stage_num;
	unsigned mem;
	bool buff_realloced;

#if !defined(IS_ISP_2500_SYSTEM)
	/* struct is > 128 bytes so it should not be on stack (see checkpatch) */
	static struct ia_css_macc_table converted_macc_table;
#endif

	assert(params != NULL);
	assert(ddr_map != NULL);
	assert(ddr_map_size != NULL);
	assert(stage != NULL);

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
			    "sh_css_params_write_to_ddr_internal() enter:\n");

	binary = stage->binary;
	assert(binary != NULL);

#if defined(IS_ISP_2500_SYSTEM)
	(void)pipe_id;
	(void)stage;
	(void)buff_realloced;
	(void)mem;
	(void)stage_num;
	/* pass call to product specific to handle copying of tables to DDR */
	err = sh_css_params_to_ddr( binary, ddr_map, ddr_map_size, &params->isp_parameters );
	if (err != IA_CSS_SUCCESS) return err;
#else  /* !defined(IS_ISP_2500_SYSTEM) */

	stage_num = stage->stage_num;

	for (mem = 0; mem < N_IA_CSS_ISP_MEMORIES; mem++) {
		const struct ia_css_isp_data *isp_data =
			ia_css_isp_param_get_isp_mem_init(&binary->info->sp.mem_initializers, IA_CSS_PARAM_CLASS_PARAM, mem);
		size_t size = isp_data->size;
		if (!size) continue;
		buff_realloced = reallocate_buffer(&ddr_map->isp_mem_param[stage_num][mem],
			&ddr_map_size->isp_mem_param[stage_num][mem],
			size,
			params->isp_mem_params_changed[pipe_id][stage_num][mem],
			&err);
		if (err != IA_CSS_SUCCESS)
			return err;
		if (params->isp_mem_params_changed[pipe_id][stage_num][mem] || buff_realloced) {
			sh_css_update_isp_mem_params_to_ddr(binary,
				ddr_map->isp_mem_param[stage_num][mem],
				ddr_map_size->isp_mem_param[stage_num][mem], mem);
		}
	}

	if (binary->info->sp.enable.fpnr) {
		buff_realloced = reallocate_buffer(&ddr_map->fpn_tbl,
			&ddr_map_size->fpn_tbl,
			(size_t)(FPNTBL_BYTES(binary)),
			params->config_changed[IA_CSS_FPN_ID],
			&err);
		if (err != IA_CSS_SUCCESS)
			return err;
		if (params->config_changed[IA_CSS_FPN_ID] || buff_realloced) {
			if (params->fpn_config.enabled) {
				store_fpntbl(params, ddr_map->fpn_tbl);
			}
#ifdef HRT_CSIM
			else {
				hrt_vaddress ptr =
					(hrt_vaddress)ddr_map->fpn_tbl;
				/* prevent warnings when reading fpn table
				 * in csim.*/
				/* Actual values are not used when fpn is
				 * disabled. */
				/* MW: fpn_tbl_size*sizeof(whatever)? */
				mmgr_clear(ptr, ddr_map_size->fpn_tbl);
			}
#endif
		}
	}
	if (binary->info->sp.enable.sc) {
		buff_realloced = reallocate_buffer(&ddr_map->sc_tbl,
			&ddr_map_size->sc_tbl,
			(size_t)(SCTBL_BYTES(binary)),
			params->sc_table_changed,
			&err);
		if (err != IA_CSS_SUCCESS)
			return err;
		if (params->sc_table_changed || buff_realloced) {
			/* shading table is full resolution, reduce */			
			prepare_shading_table(
				(const struct ia_css_shading_table *)params->sc_table,
				params->sensor_binning,
				&params->sc_config,
				binary);
			if (params->sc_config == NULL)
				return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
			store_sctbl(stage, ddr_map->sc_tbl, params->sc_config);
			ia_css_kernel_process_param[IA_CSS_SC_ID](pipe_id, stage, params);

			ia_css_shading_table_free(params->sc_config);
			params->sc_config = NULL;
		}
	}

	if (params->anr_thres_changed) {
		reallocate_buffer(&ddr_map->anr_thres,
				  &ddr_map_size->anr_thres,
				  ddr_map_size->anr_thres,
				  true,
				  &err);
		if (err != IA_CSS_SUCCESS)
			return err;
		mmgr_store(ddr_map->anr_thres,
				     &(params->anr_thres.data),
				     ddr_map_size->anr_thres);
	}
	if (params->config_changed[IA_CSS_MACC_ID] && binary->info->sp.enable.macc) {
		unsigned int i, j, idx;
		unsigned int idx_map[] = {
			0, 1, 3, 2, 6, 7, 5, 4, 12, 13, 15, 14, 10, 11, 9, 8};

		for (i = 0; i < IA_CSS_MACC_NUM_AXES; i++) {
			idx = 4*idx_map[i];
			j   = 4*i;

			if (binary->info->sp.isp_pipe_version == 1) {
				converted_macc_table.data[idx] =
				  sDIGIT_FITTING(params->macc_table.data[j],
				  13, SH_CSS_MACC_COEF_SHIFT);
				converted_macc_table.data[idx+1] =
				  sDIGIT_FITTING(params->macc_table.data[j+1],
				  13, SH_CSS_MACC_COEF_SHIFT);
				converted_macc_table.data[idx+2] =
				  sDIGIT_FITTING(params->macc_table.data[j+2],
				  13, SH_CSS_MACC_COEF_SHIFT);
				converted_macc_table.data[idx+3] =
				  sDIGIT_FITTING(params->macc_table.data[j+3],
				  13, SH_CSS_MACC_COEF_SHIFT);
			} else {
				converted_macc_table.data[idx] =
					params->macc_table.data[j];
				converted_macc_table.data[idx+1] =
					params->macc_table.data[j+1];
				converted_macc_table.data[idx+2] =
					params->macc_table.data[j+2];
				converted_macc_table.data[idx+3] =
					params->macc_table.data[j+3];
			}
		}
		reallocate_buffer(&ddr_map->macc_tbl,
				  &ddr_map_size->macc_tbl,
				  ddr_map_size->macc_tbl,
				  true,
				  &err);
		if (err != IA_CSS_SUCCESS)
			return err;
		mmgr_store(ddr_map->macc_tbl,
				     converted_macc_table.data,
				     sizeof(converted_macc_table.data));
	}

	if (binary->info->sp.enable.dvs_6axis) {
		buff_realloced = reallocate_buffer(
				&ddr_map->dvs_6axis_params_y,
				&ddr_map_size->dvs_6axis_params_y,
				(size_t)((DVS_6AXIS_BYTES(binary) / 2) * 3), // because UV is packed into the Y plane, calc total YYU size = /2 gives size of UV-only, total YYU size = UV-only * 3
				params->dvs_6axis_config_changed,
				&err);
		if (err != IA_CSS_SUCCESS)
			return err;
		if (params->dvs_6axis_config_changed || buff_realloced) {
			if(params->dvs_6axis_config == NULL) /* Generate default DVS unity table on start up*/
			{
				struct ia_css_resolution dvs_offset;
				dvs_offset.width  = (PIX_SHIFT_FILTER_RUN_IN_X + binary->dvs_envelope.width) / 2;
				dvs_offset.height = (PIX_SHIFT_FILTER_RUN_IN_Y + binary->dvs_envelope.height) / 2;

				params->dvs_6axis_config = generate_dvs_6axis_table(&binary->out_frame_info.res,
										    &dvs_offset);
				if(params->dvs_6axis_config == NULL)
					return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
			}

			store_dvs_6axis_config(params,
						binary,
						ddr_map->dvs_6axis_params_y);
		}
	}

	if (binary->info->sp.enable.dis) {
		buff_realloced = reallocate_buffer(&ddr_map->sdis_hor_coef,
				  &ddr_map_size->sdis_hor_coef,
				  (size_t)(SDIS_HOR_COEF_TBL_BYTES(binary)),
				  params->dis_coef_table_changed,
				  &err);
		if (err != IA_CSS_SUCCESS)
			return err;
		buff_realloced |= reallocate_buffer(&ddr_map->sdis_ver_coef,
				  &ddr_map_size->sdis_ver_coef,
				  (size_t)(SDIS_VER_COEF_TBL_BYTES(binary)),
				  params->dis_coef_table_changed,
				  &err);
		if (err != IA_CSS_SUCCESS)
			return err;
		if (binary->info->sp.isp_pipe_version == 2) {
			if (params->dvs2_coef_table_changed || buff_realloced) {
				store_dvs2_coefficients(params, binary,
					ddr_map->sdis_hor_coef, ddr_map->sdis_ver_coef);
			}
		} else {
			if (params->dis_coef_table_changed || buff_realloced) {
				store_dis_coefficients(params, binary,
					ddr_map->sdis_hor_coef, ddr_map->sdis_ver_coef);
			}
		}
	}

	if (binary->info->sp.enable.ca_gdc) {
		unsigned int i;
		hrt_vaddress *virt_addr_tetra_x[
			IA_CSS_MORPH_TABLE_NUM_PLANES];
		size_t *virt_size_tetra_x[
			IA_CSS_MORPH_TABLE_NUM_PLANES];
		hrt_vaddress *virt_addr_tetra_y[
			IA_CSS_MORPH_TABLE_NUM_PLANES];
		size_t *virt_size_tetra_y[
			IA_CSS_MORPH_TABLE_NUM_PLANES];

			virt_addr_tetra_x[0] = &ddr_map->tetra_r_x;
			virt_addr_tetra_x[1] = &ddr_map->tetra_gr_x;
			virt_addr_tetra_x[2] = &ddr_map->tetra_gb_x;
			virt_addr_tetra_x[3] = &ddr_map->tetra_b_x;
			virt_addr_tetra_x[4] = &ddr_map->tetra_ratb_x;
			virt_addr_tetra_x[5] = &ddr_map->tetra_batr_x;

			virt_size_tetra_x[0] = &ddr_map_size->tetra_r_x;
			virt_size_tetra_x[1] = &ddr_map_size->tetra_gr_x;
			virt_size_tetra_x[2] = &ddr_map_size->tetra_gb_x;
			virt_size_tetra_x[3] = &ddr_map_size->tetra_b_x;
			virt_size_tetra_x[4] = &ddr_map_size->tetra_ratb_x;
			virt_size_tetra_x[5] = &ddr_map_size->tetra_batr_x;

			virt_addr_tetra_y[0] = &ddr_map->tetra_r_y;
			virt_addr_tetra_y[1] = &ddr_map->tetra_gr_y;
			virt_addr_tetra_y[2] = &ddr_map->tetra_gb_y;
			virt_addr_tetra_y[3] = &ddr_map->tetra_b_y;
			virt_addr_tetra_y[4] = &ddr_map->tetra_ratb_y;
			virt_addr_tetra_y[5] = &ddr_map->tetra_batr_y;

			virt_size_tetra_y[0] = &ddr_map_size->tetra_r_y;
			virt_size_tetra_y[1] = &ddr_map_size->tetra_gr_y;
			virt_size_tetra_y[2] = &ddr_map_size->tetra_gb_y;
			virt_size_tetra_y[3] = &ddr_map_size->tetra_b_y;
			virt_size_tetra_y[4] = &ddr_map_size->tetra_ratb_y;
			virt_size_tetra_y[5] = &ddr_map_size->tetra_batr_y;

		buff_realloced = false;
		for (i = 0; i < IA_CSS_MORPH_TABLE_NUM_PLANES; i++) {
			buff_realloced |=
					reallocate_buffer(virt_addr_tetra_x[i],
						virt_size_tetra_x[i],
						(size_t)
						  (MORPH_PLANE_BYTES(binary)),
						params->morph_table_changed,
						&err);
			if (err != IA_CSS_SUCCESS)
				return err;
			buff_realloced |=
					reallocate_buffer(virt_addr_tetra_y[i],
						virt_size_tetra_y[i],
						(size_t)
						  (MORPH_PLANE_BYTES(binary)),
						params->morph_table_changed,
						&err);
			if (err != IA_CSS_SUCCESS)
				return err;
		}
		if (params->morph_table_changed || buff_realloced) {
			const struct ia_css_morph_table *table = params->morph_table;
			struct ia_css_morph_table *id_table = NULL;

			if ((table != NULL) &&
			    (table->width < binary->morph_tbl_width ||
			     table->height < binary->morph_tbl_height)) {
				table = NULL;
			}
			if (table == NULL) {
				err = sh_css_params_default_morph_table(&id_table,
								  binary);
				if (err != IA_CSS_SUCCESS)
					return err;
				table = id_table;
			}

			for (i = 0; i < IA_CSS_MORPH_TABLE_NUM_PLANES; i++) {
				write_morph_plane(table->coordinates_x[i],
					table->width,
					table->height,
					*virt_addr_tetra_x[i],
					binary->morph_tbl_aligned_width);
				write_morph_plane(table->coordinates_y[i],
					table->width,
					table->height,
					*virt_addr_tetra_y[i],
					binary->morph_tbl_aligned_width);
			}
			if (id_table != NULL)
				ia_css_morph_table_free(id_table);
		}
	}

	/* After special cases like SC, FPN since they may change parameters */
	for (mem = 0; mem < N_IA_CSS_ISP_MEMORIES; mem++) {
		const struct ia_css_isp_data *isp_data =
			ia_css_isp_param_get_isp_mem_init(&binary->info->sp.mem_initializers, IA_CSS_PARAM_CLASS_PARAM, mem);
		size_t size = isp_data->size;
		if (!size) continue;
		buff_realloced = reallocate_buffer(&ddr_map->isp_mem_param[stage_num][mem],
			&ddr_map_size->isp_mem_param[stage_num][mem],
			size,
			params->isp_mem_params_changed[pipe_id][stage_num][mem],
			&err);
		if (err != IA_CSS_SUCCESS)
			return err;
		if (params->isp_mem_params_changed[pipe_id][stage_num][mem] || buff_realloced) {
			sh_css_update_isp_mem_params_to_ddr(binary,
				ddr_map->isp_mem_param[stage_num][mem],
				ddr_map_size->isp_mem_param[stage_num][mem], mem);
		}
	}

#endif
	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_params_write_to_ddr_internal() leave:\n");

return IA_CSS_SUCCESS;
}

/**
 * Currently this function is called from:
 *  - sh_css_commit_isp_config
 *    (loops through the stages in a pipe to reconfigure settings)
 */
enum ia_css_err
sh_css_params_write_to_ddr(struct ia_css_stream *stream,
			   struct ia_css_pipeline_stage *stage)
{
	int i;
	enum ia_css_err err = IA_CSS_SUCCESS;
	struct ia_css_isp_parameters *params;

	assert(stream != NULL);

	params = stream->isp_params_configs;

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "sh_css_params_write_to_ddr() enter:\n");

	for (i = 0; i < stream->num_pipes; i++) {
		struct ia_css_pipe *pipe = stream->pipes[i];
		struct ia_css_pipeline *pipeline;
		pipeline = ia_css_pipe_get_pipeline(pipe);
		err = sh_css_params_write_to_ddr_internal(
				pipeline->pipe_id,
				params,
				stage,
				&params->pipe_ddr_ptrs[pipeline->pipe_id],
				&params->pipe_ddr_ptrs_size[pipeline->pipe_id]);
		if (err != IA_CSS_SUCCESS)
			break;
	}

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_params_write_to_ddr() leave:\n");

	return err;
}

const struct ia_css_fpn_table *ia_css_get_fpn_table(struct ia_css_stream *stream)
{
	struct ia_css_isp_parameters *params;

	assert(stream != NULL);

	params = stream->isp_params_configs;

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
			    "ia_css_get_fpn_table() enter & leave:\n");
	return &(params->fpn_config);
}

#if !defined(IS_ISP_2500_SYSTEM)
struct ia_css_shading_table * ia_css_get_shading_table(struct ia_css_stream *stream)
{
	struct ia_css_shading_table *sc_config = NULL;
	struct ia_css_binary *binary = NULL;
	struct ia_css_isp_parameters *params;
	int i;

	assert(stream != NULL);

	params = stream->isp_params_configs;

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
			    "ia_css_get_shading_table() enter:\n");

	for (i = 0; i < stream->num_pipes; i++) {
		struct ia_css_pipe *pipe = stream->pipes[i];
		struct ia_css_pipeline *pipeline;
		struct ia_css_pipeline_stage *stage;
		//unsigned int thread_id;

		pipeline = ia_css_pipe_get_pipeline(pipe);
		assert(pipeline != NULL);

		for (stage = pipeline->stages; stage; stage = stage->next) {
			if (stage && stage->binary) {
				if (stage->binary->info->sp.enable.sc) {
					binary = stage->binary;
					break;
				}
			}
		}
		if (binary)
			break;
	}
	if (binary)
		prepare_shading_table(
			(const struct ia_css_shading_table *)params->sc_table,
			params->sensor_binning,
			&sc_config,
			binary);

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_get_shading_table() leave:\n");

	return sc_config;
}
#endif

#if !defined(IS_ISP_2500_SYSTEM)
void ia_css_get_isp_dis_coefficients(
	struct ia_css_stream *stream,
	short *horizontal_coefficients,
	short *vertical_coefficients)
{
	struct ia_css_isp_parameters *params;
	unsigned int hor_num_isp, ver_num_isp;
	int i;
	short *hor_ptr = horizontal_coefficients,
	      *ver_ptr = vertical_coefficients;
	hrt_vaddress hor_ptr_isp;
	hrt_vaddress ver_ptr_isp;
	struct ia_css_binary *dvs_binary;

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_get_isp_dis_coefficients() enter\n");
	assert(horizontal_coefficients != NULL);
	assert(vertical_coefficients != NULL);

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
			    "ia_css_get_isp_dis_coefficients() enter\n");

	params = stream->isp_params_configs;

	/* Only video pipe supports DVS */
	hor_ptr_isp = params->pipe_ddr_ptrs[IA_CSS_PIPE_ID_VIDEO].sdis_hor_coef;
	ver_ptr_isp = params->pipe_ddr_ptrs[IA_CSS_PIPE_ID_VIDEO].sdis_ver_coef;
	dvs_binary = ia_css_stream_get_dvs_binary(stream);
	if (!dvs_binary)
		return;

	hor_num_isp = dvs_binary->dis_hor_coef_num_isp;
	ver_num_isp = dvs_binary->dis_ver_coef_num_isp;

	for (i = 0; i < IA_CSS_DVS_NUM_COEF_TYPES; i++) {
		mmgr_load(hor_ptr_isp, hor_ptr, hor_num_isp * sizeof(short));
		hor_ptr_isp += hor_num_isp * sizeof(short);
		hor_ptr     += hor_num_isp;
	}
	for (i = 0; i < SH_CSS_DIS_VER_NUM_COEF_TYPES(dvs_binary); i++) {
		mmgr_load(ver_ptr_isp, ver_ptr, ver_num_isp * sizeof(short));
		ver_ptr_isp += ver_num_isp * sizeof(short);
		ver_ptr     += ver_num_isp;
	}

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_get_isp_dis_coefficients() leave\n");
}
#endif

#if !defined(IS_ISP_2500_SYSTEM)
void ia_css_get_isp_dvs2_coefficients(struct ia_css_stream *stream,
	short *hor_coefs_odd_real,
	short *hor_coefs_odd_imag,
	short *hor_coefs_even_real,
	short *hor_coefs_even_imag,
	short *ver_coefs_odd_real,
	short *ver_coefs_odd_imag,
	short *ver_coefs_even_real,
	short *ver_coefs_even_imag)
{
	struct ia_css_isp_parameters *params;
	unsigned int hor_num_3a, ver_num_3a;
	unsigned int hor_num_isp, ver_num_isp;
	hrt_vaddress hor_ptr_isp;
	hrt_vaddress ver_ptr_isp;
	struct ia_css_binary *dvs_binary;

	assert(stream != NULL);
	assert(hor_coefs_odd_real != NULL);
	assert(hor_coefs_odd_imag != NULL);
	assert(hor_coefs_even_real != NULL);
	assert(hor_coefs_even_imag != NULL);
	assert(ver_coefs_odd_real != NULL);
	assert(ver_coefs_odd_imag != NULL);
	assert(ver_coefs_even_real != NULL);
	assert(ver_coefs_even_imag != NULL);

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
			    "ia_css_get_isp_dvs2_coefficients() enter\n");

	params = stream->isp_params_configs;

	/* Only video pipe supports DVS */
	hor_ptr_isp = params->pipe_ddr_ptrs[IA_CSS_PIPE_ID_VIDEO].sdis_hor_coef;
	ver_ptr_isp = params->pipe_ddr_ptrs[IA_CSS_PIPE_ID_VIDEO].sdis_ver_coef;
	dvs_binary = ia_css_stream_get_dvs_binary(stream);
	if (!dvs_binary)
		return;

	hor_num_3a  = dvs_binary->dis_hor_coef_num_3a;
	ver_num_3a  = dvs_binary->dis_ver_coef_num_3a;
	hor_num_isp = dvs_binary->dis_hor_coef_num_isp;
	ver_num_isp = dvs_binary->dis_ver_coef_num_isp;

	mmgr_load(hor_ptr_isp, hor_coefs_odd_real, hor_num_3a * sizeof(short));
	hor_ptr_isp += hor_num_isp * sizeof(short);
	mmgr_load(hor_ptr_isp, hor_coefs_odd_imag, hor_num_3a * sizeof(short));
	hor_ptr_isp += hor_num_isp * sizeof(short);
	mmgr_load(hor_ptr_isp, hor_coefs_even_real, hor_num_3a * sizeof(short));
	hor_ptr_isp += hor_num_isp * sizeof(short);
	mmgr_load(hor_ptr_isp, hor_coefs_even_imag, hor_num_3a * sizeof(short));

	mmgr_load(ver_ptr_isp, ver_coefs_odd_real, ver_num_3a * sizeof(short));
	ver_ptr_isp += ver_num_isp * sizeof(short);
	mmgr_load(ver_ptr_isp, ver_coefs_odd_imag, ver_num_3a * sizeof(short));
	ver_ptr_isp += ver_num_isp * sizeof(short);
	mmgr_load(ver_ptr_isp, ver_coefs_even_real, ver_num_3a * sizeof(short));
	ver_ptr_isp += ver_num_isp * sizeof(short);
	mmgr_load(ver_ptr_isp, ver_coefs_even_imag, ver_num_3a * sizeof(short));

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_get_isp_dvs2_coefficients() leave\n");
}
#endif

hrt_vaddress sh_css_store_sp_group_to_ddr(void)
{
	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_store_sp_group_to_ddr() enter & leave:\n");
	mmgr_store(xmem_sp_group_ptrs,
			     &sh_css_sp_group,
			     sizeof(struct sh_css_sp_group));
	return xmem_sp_group_ptrs;
}

hrt_vaddress sh_css_store_sp_stage_to_ddr(
	unsigned pipe,
	unsigned stage)
{
	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_store_sp_stage_to_ddr() enter & leave:\n");
	mmgr_store(xmem_sp_stage_ptrs[pipe][stage],
			     &sh_css_sp_stage,
			     sizeof(struct sh_css_sp_stage));
	return xmem_sp_stage_ptrs[pipe][stage];
}

hrt_vaddress sh_css_store_isp_stage_to_ddr(
	unsigned pipe,
	unsigned stage)
{
	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_store_isp_stage_to_ddr() enter & leave:\n");
	mmgr_store(xmem_isp_stage_ptrs[pipe][stage],
			     &sh_css_isp_stage,
			     sizeof(struct sh_css_isp_stage));
	return xmem_isp_stage_ptrs[pipe][stage];
}

static enum ia_css_err ref_sh_css_ddr_address_map(
	struct sh_css_ddr_address_map *map,
	struct sh_css_ddr_address_map *out)
{
	enum ia_css_err err = IA_CSS_SUCCESS;
	unsigned int i;

	hrt_vaddress *in_addrs = (hrt_vaddress *)map;
	hrt_vaddress *to_addrs = (hrt_vaddress *)out;

	assert(map != NULL);
	assert(out != NULL);

	assert(sizeof(struct sh_css_ddr_address_map_size)/sizeof(size_t) ==
	       sizeof(struct sh_css_ddr_address_map)/sizeof(hrt_vaddress));

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
			    "ref_sh_css_ddr_address_map() enter:\n");

	/* copy map using size info */
	assert(sizeof(struct sh_css_ddr_address_map_size)/sizeof(size_t) ==
	       sizeof(struct sh_css_ddr_address_map)/sizeof(hrt_vaddress));
	for (i = 0; i < (sizeof(struct sh_css_ddr_address_map_size)/
						sizeof(size_t)); i++) {
		to_addrs[i] = mmgr_NULL;
		if (in_addrs[i] == mmgr_NULL)
			continue;

		to_addrs[i] = ia_css_refcount_increment(IA_CSS_REFCOUNT_PARAM_BUFFER, in_addrs[i]);
	}

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "ref_sh_css_ddr_address_map() leave:\n");

	return err;
}

static enum ia_css_err write_sh_css_address_map_to_ddr(
	struct sh_css_ddr_address_map *me,
	hrt_vaddress *out)
{
	enum ia_css_err err = IA_CSS_SUCCESS;
	bool succ;

	assert(me != NULL);
	assert(out != NULL);

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "write_sh_css_address_map_to_ddr() enter:\n");

	*out = ia_css_refcount_increment(IA_CSS_REFCOUNT_PARAM_SET_POOL, mmgr_malloc(
				sizeof(struct sh_css_ddr_address_map)));
	succ = (*out != mmgr_NULL);
	if (succ)
		mmgr_store(*out,
			me, sizeof(struct sh_css_ddr_address_map));
	else
		err = IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "write_sh_css_address_map_to_ddr() leave:\n");

	return err;
}

static enum ia_css_err
free_sh_css_ddr_address_map(
	hrt_vaddress ptr)
{
	enum ia_css_err err = IA_CSS_SUCCESS;
	struct sh_css_ddr_address_map map;
	unsigned int i;
	hrt_vaddress *addrs = (hrt_vaddress *)&map;

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "free_sh_css_ddr_address_map() enter:\n");

	mmgr_load(ptr, &map, sizeof(struct sh_css_ddr_address_map));
	/* copy map using size info */
	for (i = 0; i < (sizeof(struct sh_css_ddr_address_map_size)/
						sizeof(size_t)); i++) {
		if (addrs[i] == mmgr_NULL)
			continue;
		ia_css_refcount_decrement(IA_CSS_REFCOUNT_PARAM_BUFFER, addrs[i]);
	}
	ia_css_refcount_decrement(IA_CSS_REFCOUNT_PARAM_SET_POOL, ptr);

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE, "free_sh_css_ddr_address_map() leave:\n");

	return err;
}

/* Mark all parameters as changed to force recomputing the derived ISP parameters */
void
sh_css_invalidate_params(struct ia_css_stream *stream)
{
	struct	ia_css_isp_parameters *params;
	unsigned i, j, mem;

	assert(stream != NULL);

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
			    "sh_css_invalidate_params() enter:\n");

	params = stream->isp_params_configs;
	params->isp_params_changed = true;
	for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++) {
		for (j = 0; j < SH_CSS_MAX_STAGES; j++) {
			for (mem = 0; mem < N_IA_CSS_ISP_MEMORIES; mem++) {
				params->isp_mem_params_changed[i][j][mem] = true;
			}
		}
	}

	memset(&params->config_changed[0], 1, sizeof(params->config_changed));
	params->dis_coef_table_changed = true;
	params->dvs2_coef_table_changed = true;
	params->morph_table_changed = true;
	params->sc_table_changed = true;
	params->anr_thres_changed = true;
	params->dz_config_changed = true;
	params->motion_config_changed = true;

	/*Free up theDVS table memory blocks before recomputing new table  */
	if(params->dvs_6axis_config)
		free_dvs_6axis_table(&(params->dvs_6axis_config));
	params->dvs_6axis_config_changed = true;

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_invalidate_params() leave:\n");
}

#if !defined(IS_ISP_2500_SYSTEM)
void
sh_css_update_uds_and_crop_info(
	const struct ia_css_binary_info *info,
	const struct ia_css_frame_info *in_frame_info,
	const struct ia_css_frame_info *out_frame_info,
	const struct ia_css_resolution *dvs_env,
	bool preview_mode,
	const struct ia_css_dz_config *zoom,
	const struct ia_css_vector *motion_vector,
	struct sh_css_uds_info *uds,		/* out */
	struct sh_css_crop_pos *sp_out_crop_pos)/* out */
{
	assert(info != NULL);
	assert(in_frame_info != NULL);
	assert(out_frame_info != NULL);
	assert(dvs_env != NULL);
	assert(zoom != NULL);
	assert(motion_vector != NULL);
	assert(uds != NULL);
	assert(sp_out_crop_pos != NULL);

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE_PRIVATE,
			    "sh_css_update_uds_and_crop_info() enter:\n");

	if (info->mode == IA_CSS_BINARY_MODE_VF_PP && !preview_mode) {
		/* in non-preview modes, VF_PP does not do
		   the zooming, capture_pp or video do. */
		uds->curr_dx = HRT_GDC_N;
		uds->curr_dy = HRT_GDC_N;
	} else {
		uds->curr_dx   = (uint16_t)zoom->dx;
		uds->curr_dy   = (uint16_t)zoom->dy;
	}

	if (info->enable.dvs_envelope) {
		unsigned int crop_x = 0,
			     crop_y = 0,
			     uds_xc = 0,
			     uds_yc = 0,
			     env_width, env_height;
		int half_env_x, half_env_y;
		int motion_x = motion_vector->x;
		int motion_y = motion_vector->y;
		bool upscale_x = in_frame_info->res.width < out_frame_info->res.width;
		bool upscale_y = in_frame_info->res.height < out_frame_info->res.height;

		if (info->enable.uds && !info->enable.ds) {
			/**
			 * we calculate with the envelope that we can actually
			 * use, the min dvs envelope is for the filter
			 * initialization.
			 */
			env_width  = dvs_env->width -
					SH_CSS_MIN_DVS_ENVELOPE;
			env_height = dvs_env->height -
					SH_CSS_MIN_DVS_ENVELOPE;
			half_env_x = env_width / 2;
			half_env_y = env_height / 2;
			/**
			 * for digital zoom, we use the dvs envelope and make
			 * sure that we don't include the 8 leftmost pixels or
			 * 8 topmost rows.
			 */
			if (upscale_x) {
				uds_xc = (in_frame_info->res.width
					+ env_width
					+ SH_CSS_MIN_DVS_ENVELOPE) / 2;
			} else {
				uds_xc = (out_frame_info->res.width
							+ env_width) / 2
					+ SH_CSS_MIN_DVS_ENVELOPE;
			}
			if (upscale_y) {
				uds_yc = (in_frame_info->res.height
					+ env_height
					+ SH_CSS_MIN_DVS_ENVELOPE) / 2;
			} else {
				uds_yc = (out_frame_info->res.height
							+ env_height) / 2
					+ SH_CSS_MIN_DVS_ENVELOPE;
			}
			/* clip the motion vector to +/- half the envelope */
			motion_x = clamp(motion_x, -half_env_x, half_env_x);
			motion_y = clamp(motion_y, -half_env_y, half_env_y);
			uds_xc += motion_x;
			uds_yc += motion_y;
			/* uds can be pipelined, remove top lines */
			crop_y = 2;
		} else if (info->enable.ds) {
			env_width  = dvs_env->width;
			env_height = dvs_env->height;
			half_env_x = env_width / 2;
			half_env_y = env_height / 2;
			/* clip the motion vector to +/- half the envelope */
			motion_x = clamp(motion_x, -half_env_x, half_env_x);
			motion_y = clamp(motion_y, -half_env_y, half_env_y);
			/* for video with downscaling, the envelope is included
			    in the input resolution. */
			uds_xc = in_frame_info->res.width/2 + motion_x;
			uds_yc = in_frame_info->res.height/2 + motion_y;
			crop_x = info->left_cropping;
			/* ds == 2 (yuv_ds) can be pipelined, remove top
			   lines */
			if (info->enable.ds & 1)
				crop_y = info->top_cropping;
			else
				crop_y = 2;
		} else {
			/* video nodz: here we can only crop. We make sure we
			   crop at least the first 8x8 pixels away. */
			env_width  = dvs_env->width -
					SH_CSS_MIN_DVS_ENVELOPE;
			env_height = dvs_env->height -
					SH_CSS_MIN_DVS_ENVELOPE;
			half_env_x = env_width / 2;
			half_env_y = env_height / 2;
			motion_x = clamp(motion_x, -half_env_x, half_env_x);
			motion_y = clamp(motion_y, -half_env_y, half_env_y);
			crop_x = SH_CSS_MIN_DVS_ENVELOPE
						+ half_env_x + motion_x;
			crop_y = SH_CSS_MIN_DVS_ENVELOPE
						+ half_env_y + motion_y;
		}

		/* Must enforce that the crop position is even */
		crop_x = EVEN_FLOOR(crop_x);
		crop_y = EVEN_FLOOR(crop_y);
		uds_xc = EVEN_FLOOR(uds_xc);
		uds_yc = EVEN_FLOOR(uds_yc);

		uds->xc = (uint16_t)uds_xc;
		uds->yc = (uint16_t)uds_yc;
		sp_out_crop_pos->x = (uint16_t)crop_x;
		sp_out_crop_pos->y = (uint16_t)crop_y;
	}
	else {
		/* for down scaling, we always use the center of the image */
		uds->xc = (uint16_t)in_frame_info->res.width / 2;
		uds->yc = (uint16_t)in_frame_info->res.height / 2;
		sp_out_crop_pos->x = (uint16_t)info->left_cropping;
		sp_out_crop_pos->y = (uint16_t)info->top_cropping;
	}
	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "sh_css_update_uds_and_crop_info() leave:\n");
}
#endif

#if !defined(IS_ISP_2500_SYSTEM)
struct ia_css_3a_statistics *
ia_css_3a_statistics_allocate(const struct ia_css_3a_grid_info *grid)
{
	struct ia_css_3a_statistics *me;
	int grid_size;

	assert(grid != NULL);

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_3a_statistics_allocate() enter: grid=%p\n",grid);

	me = sh_css_calloc(1,sizeof(*me));
	if (!me)
		goto err;

	me->grid = *grid;
	grid_size = grid->width * grid->height;
	me->data = sh_css_malloc(grid_size * sizeof(*me->data));
	if (!me->data)
		goto err;
#if !defined(HAS_NO_HMEM)
	/* No weighted histogram, no structure, treat the histogram data as a byte dump in a byte array */
	me->rgby_data = (struct ia_css_3a_rgby_output *)sh_css_malloc(sizeof_hmem(HMEM0_ID));
#else
	me->rgby_data = NULL;
#endif

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_3a_statistics_allocate() leave: return=%p\n",me);

	return me;
err:
	ia_css_3a_statistics_free(me);

	ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "ia_css_3a_statistics_allocate() leave: return=%p\n",NULL);

	return NULL;
}
#endif

void
ia_css_3a_statistics_free(struct ia_css_3a_statistics *me)
{
	if (me) {
		sh_css_free(me->rgby_data);
		sh_css_free(me->data);
		sh_css_free(me);
	}
}

struct ia_css_dvs_statistics *
ia_css_dvs_statistics_allocate(const struct ia_css_dvs_grid_info *grid)
{
	struct ia_css_dvs_statistics *me;

	assert(grid != NULL);

	me = sh_css_calloc(1,sizeof(*me));
	if (!me)
		goto err;

	me->grid = *grid;
	me->hor_proj = sh_css_malloc(grid->height * IA_CSS_DVS_NUM_COEF_TYPES *
					sizeof(*me->hor_proj));
	if (!me->hor_proj)
		goto err;

	me->ver_proj = sh_css_malloc(grid->width * IA_CSS_DVS_NUM_COEF_TYPES *
					sizeof(*me->ver_proj));
	if (!me->ver_proj)
		goto err;

	return me;
err:
	ia_css_dvs_statistics_free(me);
	return NULL;

}

void
ia_css_dvs_statistics_free(struct ia_css_dvs_statistics *me)
{
	if (me) {
		sh_css_free(me->hor_proj);
		sh_css_free(me->ver_proj);
		sh_css_free(me);
	}
}

struct ia_css_dvs_coefficients *
ia_css_dvs_coefficients_allocate(const struct ia_css_dvs_grid_info *grid)
{
	struct ia_css_dvs_coefficients *me;

	assert(grid != NULL);

	me = sh_css_calloc(1,sizeof(*me));
	if (!me)
		goto err;

	me->grid = *grid;

	me->hor_coefs = sh_css_malloc(grid->num_hor_coefs *
				IA_CSS_DVS_NUM_COEF_TYPES *
				sizeof(*me->hor_coefs));
	if (!me->hor_coefs)
		goto err;

	me->ver_coefs = sh_css_malloc(grid->num_ver_coefs *
				IA_CSS_DVS_NUM_COEF_TYPES *
				sizeof(*me->ver_coefs));
	if (!me->ver_coefs)
		goto err;

	return me;
err:
	ia_css_dvs_coefficients_free(me);
	return NULL;
}

void
ia_css_dvs_coefficients_free(struct ia_css_dvs_coefficients *me)
{
	if (me) {
		sh_css_free(me->hor_coefs);
		sh_css_free(me->ver_coefs);
		sh_css_free(me);
	}
}

struct ia_css_dvs2_statistics *
ia_css_dvs2_statistics_allocate(const struct ia_css_dvs_grid_info *grid)
{
	struct ia_css_dvs2_statistics *me;

	assert(grid != NULL);

	me = sh_css_calloc(1,sizeof(*me));
	if (!me)
		goto err;

	me->grid = *grid;

	me->hor_prod.odd_real = sh_css_malloc(grid->aligned_width *
		grid->aligned_height * sizeof(*me->hor_prod.odd_real));
	if (!me->hor_prod.odd_real)
		goto err;

	me->hor_prod.odd_imag = sh_css_malloc(grid->aligned_width *
		grid->aligned_height * sizeof(*me->hor_prod.odd_imag));
	if (!me->hor_prod.odd_imag)
		goto err;

	me->hor_prod.even_real = sh_css_malloc(grid->aligned_width *
		grid->aligned_height * sizeof(*me->hor_prod.even_real));
	if (!me->hor_prod.even_real)
		goto err;

	me->hor_prod.even_imag = sh_css_malloc(grid->aligned_width *
		grid->aligned_height * sizeof(*me->hor_prod.even_imag));
	if (!me->hor_prod.even_imag)
		goto err;

	me->ver_prod.odd_real = sh_css_malloc(grid->aligned_width *
		grid->aligned_height * sizeof(*me->ver_prod.odd_real));
	if (!me->ver_prod.odd_real)
		goto err;

	me->ver_prod.odd_imag = sh_css_malloc(grid->aligned_width *
		grid->aligned_height * sizeof(*me->ver_prod.odd_imag));
	if (!me->ver_prod.odd_imag)
		goto err;

	me->ver_prod.even_real = sh_css_malloc(grid->aligned_width *
		grid->aligned_height * sizeof(*me->ver_prod.even_real));
	if (!me->ver_prod.even_real)
		goto err;

	me->ver_prod.even_imag = sh_css_malloc(grid->aligned_width *
		grid->aligned_height * sizeof(*me->ver_prod.even_imag));
	if (!me->ver_prod.even_imag)
		goto err;

	return me;
err:
	ia_css_dvs2_statistics_free(me);
	return NULL;

}

void
ia_css_dvs2_statistics_free(struct ia_css_dvs2_statistics *me)
{
	if (me) {
		sh_css_free(me->hor_prod.odd_real);
		sh_css_free(me->hor_prod.odd_imag);
		sh_css_free(me->hor_prod.even_real);
		sh_css_free(me->hor_prod.even_imag);
		sh_css_free(me->ver_prod.odd_real);
		sh_css_free(me->ver_prod.odd_imag);
		sh_css_free(me->ver_prod.even_real);
		sh_css_free(me->ver_prod.even_imag);
		sh_css_free(me);
	}
}

struct ia_css_dvs2_coefficients *
ia_css_dvs2_coefficients_allocate(const struct ia_css_dvs_grid_info *grid)
{
	struct ia_css_dvs2_coefficients *me;

	assert(grid != NULL);

	me = sh_css_calloc(1,sizeof(*me));
	if (!me)
		goto err;

	me->grid = *grid;

	me->hor_coefs.odd_real = sh_css_malloc(grid->num_hor_coefs *
		sizeof(*me->hor_coefs.odd_real));
	if (!me->hor_coefs.odd_real)
		goto err;

	me->hor_coefs.odd_imag = sh_css_malloc(grid->num_hor_coefs *
		sizeof(*me->hor_coefs.odd_imag));
	if (!me->hor_coefs.odd_imag)
		goto err;

	me->hor_coefs.even_real = sh_css_malloc(grid->num_hor_coefs *
		sizeof(*me->hor_coefs.even_real));
	if (!me->hor_coefs.even_real)
		goto err;

	me->hor_coefs.even_imag = sh_css_malloc(grid->num_hor_coefs *
		sizeof(*me->hor_coefs.even_imag));
	if (!me->hor_coefs.even_imag)
		goto err;

	me->ver_coefs.odd_real = sh_css_malloc(grid->num_ver_coefs *
		sizeof(*me->ver_coefs.odd_real));
	if (!me->ver_coefs.odd_real)
		goto err;

	me->ver_coefs.odd_imag = sh_css_malloc(grid->num_ver_coefs *
		sizeof(*me->ver_coefs.odd_imag));
	if (!me->ver_coefs.odd_imag)
		goto err;

	me->ver_coefs.even_real = sh_css_malloc(grid->num_ver_coefs *
		sizeof(*me->ver_coefs.even_real));
	if (!me->ver_coefs.even_real)
		goto err;

	me->ver_coefs.even_imag = sh_css_malloc(grid->num_ver_coefs *
		sizeof(*me->ver_coefs.even_imag));
	if (!me->ver_coefs.even_imag)
		goto err;

	return me;
err:
	ia_css_dvs2_coefficients_free(me);
	return NULL;
}

void
ia_css_dvs2_coefficients_free(struct ia_css_dvs2_coefficients *me)
{
	if (me) {
		sh_css_free(me->hor_coefs.odd_real);
		sh_css_free(me->hor_coefs.odd_imag);
		sh_css_free(me->hor_coefs.even_real);
		sh_css_free(me->hor_coefs.even_imag);
		sh_css_free(me->ver_coefs.odd_real);
		sh_css_free(me->ver_coefs.odd_imag);
		sh_css_free(me->ver_coefs.even_real);
		sh_css_free(me->ver_coefs.even_imag);
		sh_css_free(me);
	}
}

struct ia_css_dvs_6axis_config *
ia_css_dvs2_6axis_config_allocate(const struct ia_css_stream *stream)
{
    struct ia_css_dvs_6axis_config *dvs_config = NULL;
    struct ia_css_isp_parameters *params = NULL;
    unsigned int width_y;
    unsigned int height_y;
    unsigned int width_uv;
    unsigned int height_uv;

    assert(stream != NULL);
    params = stream->isp_params_configs;
    assert(params != NULL);
    assert(params->dvs_6axis_config != NULL);

    dvs_config = (struct ia_css_dvs_6axis_config *)sh_css_calloc(1, sizeof(struct ia_css_dvs_6axis_config));
    if(!dvs_config)
          goto err;

    dvs_config->width_y = width_y = params->dvs_6axis_config->width_y;
    dvs_config->height_y = height_y = params->dvs_6axis_config->height_y;
    dvs_config->width_uv = width_uv = params->dvs_6axis_config->width_uv;
    dvs_config->height_uv = height_uv = params->dvs_6axis_config->height_uv;
    ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "config_allocate table Y: W %d H %d\n",width_y,height_y);
    ia_css_debug_dtrace(IA_CSS_DEBUG_TRACE, "config_allocate table UV: W %d H %d\n",width_uv,height_uv);
    dvs_config->xcoords_y = (uint32_t *)sh_css_malloc( width_y * height_y * sizeof(uint32_t));
    if(!dvs_config->xcoords_y)
        goto err;

    dvs_config->ycoords_y = (uint32_t *)sh_css_malloc( width_y * height_y * sizeof(uint32_t));
    if(!dvs_config->ycoords_y)
        goto err;

    dvs_config->xcoords_uv = (uint32_t *)sh_css_malloc( width_uv * height_uv * sizeof(uint32_t));
    if(!dvs_config->xcoords_uv)
        goto err;

    dvs_config->ycoords_uv = (uint32_t *)sh_css_malloc( width_uv * height_uv * sizeof(uint32_t));
    if(!dvs_config->ycoords_uv)
        goto err;

    return dvs_config;
err:
        ia_css_dvs2_6axis_config_free(dvs_config);
        return NULL;
}

void
ia_css_dvs2_6axis_config_free(struct ia_css_dvs_6axis_config *dvs_6axis_config)
{
    if(dvs_6axis_config)
    {
        sh_css_free(dvs_6axis_config->xcoords_y);
        sh_css_free(dvs_6axis_config->ycoords_y);
        sh_css_free(dvs_6axis_config->xcoords_uv);
        sh_css_free(dvs_6axis_config->ycoords_uv);
        sh_css_free(dvs_6axis_config);
    }
}
